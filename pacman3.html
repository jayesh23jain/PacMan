<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New 3D Pac-Man</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0033 50%, #000814 100%);
            background-attachment: fixed;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        /* Animated background particles */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, #00ffff, transparent),
                radial-gradient(2px 2px at 40% 70%, #ff00ff, transparent),
                radial-gradient(1px 1px at 90% 40%, #ffff00, transparent);
            background-repeat: repeat;
            background-size: 200px 200px, 300px 300px, 150px 150px;
            animation: particle-float 15s linear infinite;
            opacity: 0.08;
            z-index: -1;
        }

        @keyframes particle-float {
            0% { transform: translate(0, 0) rotate(0deg); }
            100% { transform: translate(-30px, -30px) rotate(360deg); }
        }

        canvas {
            display: block;
            border-radius: 20px;
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.4),
                0 0 100px rgba(255, 0, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            border: 3px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff) 1;
            animation: canvas-glow 3s ease-in-out infinite alternate;
        }

        @keyframes canvas-glow {
            from { box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), 0 0 60px rgba(255, 0, 255, 0.1); }
            to { box-shadow: 0 0 60px rgba(0, 255, 255, 0.5), 0 0 120px rgba(255, 0, 255, 0.3); }
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: 1fr auto 2fr auto auto 1fr;
            grid-template-areas: "lives powerups score dash shield timer";
            align-items: center;
            gap: 15px;
            font-size: 18px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            text-shadow: 0 0 15px currentColor;
            opacity: 0;
            transition: all 0.5s ease;
            backdrop-filter: blur(15px);
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 20px 30px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }

        #level-display {
            color: #00ff88;
            text-shadow: 0 0 15px #00ff88, 0 0 30px #00ff88;
            animation: level-pulse 2s ease-in-out infinite alternate;
        }

        #dash-status {
            grid-area: dash;
            color: #ffff00;
            text-align: center;
            text-shadow: 0 0 15px #ffff00, 0 0 30px #ffff00;
            transition: all 0.3s ease;
        }

        #dash-status.ready {
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00;
            animation: dash-ready-pulse 1.5s ease-in-out infinite alternate;
        }

        #dash-status.recharging {
            color: #ff6600;
            text-shadow: 0 0 15px #ff6600, 0 0 30px #ff6600;
        }

        #dash-status.active {
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff, 0 0 40px #ffffff;
            animation: dash-active-pulse 0.3s ease-in-out infinite alternate;
        }

        @keyframes dash-ready-pulse {
            from { opacity: 0.7; transform: scale(1); }
            to { opacity: 1; transform: scale(1.05); }
        }

        @keyframes dash-active-pulse {
            from { opacity: 0.8; transform: scale(1.1); }
            to { opacity: 1; transform: scale(1.2); }
        }

        #shield-status {
            grid-area: shield;
            color: #00ffff;
            text-align: center;
            text-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff;
            transition: all 0.3s ease;
        }

        #shield-status.ready {
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00;
            animation: shield-ready-pulse 1.5s ease-in-out infinite alternate;
        }

        #shield-status.recharging {
            color: #ff6600;
            text-shadow: 0 0 15px #ff6600, 0 0 30px #ff6600;
        }

        #shield-status.active {
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            animation: shield-active-pulse 0.3s ease-in-out infinite alternate;
        }

        @keyframes shield-ready-pulse {
            from { opacity: 0.7; transform: scale(1); }
            to { opacity: 1; transform: scale(1.05); }
        }

        @keyframes shield-active-pulse {
            from { opacity: 0.8; transform: scale(1.1); }
            to { opacity: 1; transform: scale(1.2); }
        }

        #score {
            color: #ffffff;
            text-align: center;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #00ffff;
            font-weight: 700;
            font-size: 20px;
        }

        #lives {
            grid-area: lives;
            color: #ffff00;
            text-align: left;
            text-shadow: 0 0 15px #ffff00, 0 0 30px #ffff00;
        }

        #score {
            grid-area: score;
            color: #ffffff;
            text-align: center;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #00ffff;
            font-weight: 700;
            font-size: 20px;
        }

        #timer {
            grid-area: timer;
            color: #ff00ff;
            text-align: right;
            text-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff;
        }

        #powerup-status {
            grid-area: powerups;
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        .powerup-indicator {
            position: relative;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffffff;
            font-size: 18px;
            text-shadow: 0 0 8px currentColor;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .powerup-progress {
            position: absolute;
            top: -2px;
            left: -2px;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: #00ff00;
            transition: transform 0.1s linear;
            transform-origin: center;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .powerup-progress.warning {
            border-top-color: #ffff00;
        }

        .powerup-progress.critical {
            border-top-color: #ff0000;
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.8; }
            to { opacity: 1.0; }
        }

        @keyframes level-pulse {
            from { text-shadow: 0 0 15px currentColor, 0 0 30px currentColor; }
            to { text-shadow: 0 0 25px currentColor, 0 0 50px currentColor, 0 0 75px currentColor; }
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(20, 0, 40, 0.85) 50%, 
                rgba(0, 0, 0, 0.9) 100%);
            backdrop-filter: blur(25px);
            padding: 30px;
            border-radius: 30px;
            text-align: center;
            border: 3px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff) 1;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.5),
                0 0 120px rgba(255, 0, 255, 0.3),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
            z-index: 10;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
            animation: modal-appear 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: auto;
        }

        @keyframes modal-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.7) rotateX(30deg);
                filter: blur(10px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotateX(0deg);
                filter: blur(0px);
            }
        }

        /* Style for powerup tutorial specifically */
        #powerup-tutorial-screen {
            max-height: 90vh;
            overflow-y: auto;
            padding: 40px;
            width: 90%;
            max-width: 800px;
        }

        #powerup-tutorial-screen h1 {
            font-size: 36px;
            margin-bottom: 20px;
        }

        #powerup-tutorial-screen p {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        /* Make powerup grid more readable */
        #powerup-tutorial-screen .powerup-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }

        #powerup-tutorial-screen .powerup-item {
            text-align: center;
            padding: 20px;
            border-radius: 15px;
            font-size: 16px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        #powerup-tutorial-screen .powerup-item h3 {
            margin: 15px 0;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
        }

        #powerup-tutorial-screen .powerup-item p {
            font-size: 14px;
            line-height: 1.5;
            font-family: 'Rajdhani', sans-serif;
        }

        #powerup-tutorial-screen .powerup-item div {
            font-size: 32px;
            margin-bottom: 10px;
        }

        /* Make tips section more readable */
        #powerup-tutorial-screen .tips-section {
            background: rgba(255, 255, 0, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border: 2px solid rgba(255, 255, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        #powerup-tutorial-screen .tips-section h3 {
            margin-bottom: 15px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
        }

        #powerup-tutorial-screen .tips-section ul {
            font-size: 16px;
            line-height: 1.8;
            margin: 0;
            padding-left: 25px;
            font-family: 'Rajdhani', sans-serif;
        }

        #powerup-tutorial-screen .tips-section li {
            margin-bottom: 8px;
        }

        /* Button container */
        #powerup-tutorial-screen .button-container {
            display: flex;
            gap: 25px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        #powerup-tutorial-screen .button-container button {
            font-size: 18px !important;
            padding: 20px 40px !important;
            min-width: 200px;
        }

        /* Style for Chapter 2 powerup tutorial */
        #powerup-tutorial-2-screen {
            max-height: 90vh;
            overflow-y: auto;
            padding: 40px;
            width: 90%;
            max-width: 800px;
            background: linear-gradient(135deg, #001133, #004466);
        }
        
        #powerup-tutorial-2-screen h1 {
            color: #87ceeb;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #87ceeb;
        }
        
        #powerup-tutorial-2-screen p {
            color: #e0e8ff;
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.6;
            text-shadow: 0 0 5px #87ceeb;
        }
        
        #powerup-tutorial-2-screen .powerup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        #powerup-tutorial-2-screen .powerup-item {
            background: rgba(135, 206, 235, 0.1);
            border: 2px solid;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(135, 206, 235, 0.2);
        }
        
        #powerup-tutorial-2-screen .powerup-item h3 {
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
        }
        
        #powerup-tutorial-2-screen .powerup-item p {
            font-size: 14px;
            line-height: 1.4;
            margin: 10px 0;
            text-shadow: none;
        }
        
        #powerup-tutorial-2-screen .powerup-item div {
            font-size: 24px;
            margin-bottom: 8px;
            text-shadow: 0 0 15px currentColor;
        }
        
        #powerup-tutorial-2-screen .tips-section {
            background: rgba(135, 206, 235, 0.1);
            border: 2px solid #87ceeb;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(135, 206, 235, 0.2);
        }
        
        #powerup-tutorial-2-screen .tips-section h3 {
            color: #87ceeb;
            font-size: 22px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #87ceeb;
        }
        
        #powerup-tutorial-2-screen .tips-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }
        
        #powerup-tutorial-2-screen .tips-section li {
            color: #e0e8ff;
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        
        #powerup-tutorial-2-screen .tips-section li:before {
            content: "❄️";
            position: absolute;
            left: 0;
        }
        
        #powerup-tutorial-2-screen .button-container {
            margin-top: 30px;
        }
        
        #powerup-tutorial-2-screen .button-container button {
            font-size: 18px !important;
            padding: 20px 40px !important;
            min-width: 200px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 15px;
            background: linear-gradient(135deg, #87ceeb, #4682b4);
            color: #001133;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        #powerup-tutorial-2-screen .button-container button:hover {
            background: linear-gradient(135deg, #b0e0e6, #87ceeb);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(135, 206, 235, 0.4);
        }

        /* Controls Tutorial Screens */
        #controls-tutorial-screen, #controls-tutorial-2-screen, #controls-tutorial-3-screen {
            background: rgba(0, 10, 20, 0.85);
            backdrop-filter: blur(2px);
            border: 3px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff) 1;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 50px rgba(0, 255, 255, 0.1);
        }

        #controls-tutorial-screen h1, #controls-tutorial-2-screen h1, #controls-tutorial-3-screen h1 {
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 30px;
        }

        #controls-tutorial-screen p, #controls-tutorial-2-screen p, #controls-tutorial-3-screen p {
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            margin-bottom: 30px;
            font-size: 16px;
        }

        #controls-tutorial-screen .controls-grid, #controls-tutorial-2-screen .controls-grid, #controls-tutorial-3-screen .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 30px 0;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            justify-items: center;
            align-items: start;
        }

        #controls-tutorial-screen .control-item, #controls-tutorial-2-screen .control-item, #controls-tutorial-3-screen .control-item {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 320px;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #controls-tutorial-screen .control-item h3, #controls-tutorial-2-screen .control-item h3, #controls-tutorial-3-screen .control-item h3 {
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }

        #controls-tutorial-screen .control-item p, #controls-tutorial-2-screen .control-item p, #controls-tutorial-3-screen .control-item p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.4;
        }

        #controls-tutorial-screen .control-item .key-display, #controls-tutorial-2-screen .control-item .key-display, #controls-tutorial-3-screen .control-item .key-display {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: bold;
            font-size: 16px;
            margin: 5px;
            display: inline-block;
        }

        #controls-tutorial-screen .tips-section, #controls-tutorial-2-screen .tips-section, #controls-tutorial-3-screen .tips-section {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin: 30px auto;
            max-width: 600px;
            border: 2px solid rgba(255, 255, 0, 0.3);
        }

        #controls-tutorial-screen .tips-section h3, #controls-tutorial-2-screen .tips-section h3, #controls-tutorial-3-screen .tips-section h3 {
            margin-bottom: 15px;
            color: #ffff00;
            text-shadow: 0 0 15px #ffff00;
        }

        #controls-tutorial-screen .tips-section ul, #controls-tutorial-2-screen .tips-section ul, #controls-tutorial-3-screen .tips-section ul {
            text-align: left;
            margin: 0;
            padding-left: 20px;
        }

        #controls-tutorial-screen .tips-section li, #controls-tutorial-2-screen .tips-section li, #controls-tutorial-3-screen .tips-section li {
            margin-bottom: 8px;
            color: #ffffff;
        }

        #controls-tutorial-screen .button-container, #controls-tutorial-2-screen .button-container, #controls-tutorial-3-screen .button-container {
            margin-top: 40px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        #controls-tutorial-screen .button-container button, #controls-tutorial-2-screen .button-container button, #controls-tutorial-3-screen .button-container button {
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #fff;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        #controls-tutorial-screen .button-container button:hover, #controls-tutorial-2-screen .button-container button:hover, #controls-tutorial-3-screen .button-container button:hover {
            background: linear-gradient(45deg, #40e0e0, #4090ff);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        /* Powerup selection screen styles */
        #powerup-selection-screen .powerup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        #powerup-selection-screen .powerup-item {
            text-align: center;
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        #powerup-selection-screen .powerup-item h3 {
            margin: 15px 0;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
        }

        #powerup-selection-screen .powerup-item p {
            font-size: 14px;
            line-height: 1.5;
            font-family: 'Rajdhani', sans-serif;
            margin-bottom: 20px;
        }

        .select-powerup-button {
            font-size: 14px !important;
            padding: 12px 24px !important;
            margin: 5px !important;
            min-width: 120px !important;
        }

        h1 {
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            margin-bottom: 30px;
            text-shadow: none;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8));
            animation: gradient-shift 4s ease infinite;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        p {
            font-size: 18px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 400;
            margin-bottom: 35px;
            line-height: 1.7;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        button {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
            color: #ffffff;
            border: 2px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff) 1;
            padding: 20px 40px;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 
                0 10px 30px rgba(0, 255, 255, 0.3),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            margin: 15px;
            backdrop-filter: blur(15px);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 15px currentColor;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 15px 45px rgba(0, 255, 255, 0.5),
                0 0 40px rgba(255, 0, 255, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
        }

        button:hover::before {
            left: 100%;
        }

        button:active {
            transform: translateY(-1px);
            box-shadow: 
                0 8px 20px rgba(0, 255, 255, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
        }

        button.locked {
            background: linear-gradient(135deg, rgba(85, 85, 85, 0.3), rgba(68, 68, 68, 0.3));
            color: #888;
            cursor: not-allowed;
            border-image: linear-gradient(45deg, #555, #333) 1;
            box-shadow: none;
            transform: none;
            text-shadow: none;
            filter: grayscale(1) brightness(0.5);
        }

        button.locked:hover {
            transform: none;
            box-shadow: none;
            text-shadow: none;
        }

        button.locked::before {
            display: none;
        }

        #chapter-select-container,
        #level-select-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            justify-content: center;
            gap: 30px;
            margin: 40px 0;
        }

        .stars {
            font-size: 60px;
            background: linear-gradient(45deg, #ffff00, #ffa500, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            text-shadow: none;
            filter: drop-shadow(0 0 20px rgba(255, 255, 0, 1));
            animation: star-twinkle 2.5s ease-in-out infinite alternate;
        }

        @keyframes star-twinkle {
            from { filter: drop-shadow(0 0 15px rgba(255, 255, 0, 0.7)); }
            to { filter: drop-shadow(0 0 35px rgba(255, 255, 0, 1)) drop-shadow(0 0 50px rgba(255, 165, 0, 0.9)); }
        }

        .choice-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 35px 0;
            padding: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        /* Home screen styles */
        #home-screen {
            text-align: center;
            animation: float-in 1.2s ease-out;
        }

        #home-screen h1 {
            font-size: 64px;
            margin-bottom: 40px;
            animation: title-glow 5s ease-in-out infinite alternate;
        }

        @keyframes title-glow {
            from { filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8)); }
            to { filter: drop-shadow(0 0 40px rgba(0, 255, 255, 1)) drop-shadow(0 0 80px rgba(255, 0, 255, 0.8)); }
        }

        #home-screen p {
            font-size: 22px;
            margin-bottom: 50px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.85);
        }

        #home-screen button {
            font-size: 18px;
            padding: 25px 50px;
            margin: 20px;
        }

        @keyframes float-in {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) translateY(40px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) translateY(0px);
            }
        }

        /* Settings screen styles */
        #settings-screen {
            text-align: left;
            max-width: 600px;
            margin: 0 auto;
        }

        #settings-screen h1 {
            margin-bottom: 40px;
            text-align: center;
        }

        #settings-screen h3 {
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px currentColor;
            font-size: 18px;
        }

        #settings-screen label {
            display: block;
            margin-bottom: 12px;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            color: rgba(255, 255, 255, 0.9);
        }

        #settings-screen input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            appearance: none;
        }

        #settings-screen input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            border: 2px solid #fff;
        }

        #settings-screen select {
            width: 100%;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            color: #fff;
            backdrop-filter: blur(10px);
        }

        #settings-screen .checkbox-label {
            font-size: 16px;
        }

        #settings-screen .button-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        /* Instructions screen styles */
        #instructions-screen {
            text-align: left;
            max-width: 600px;
            margin: 0 auto;
            font-size: 16px;
        }

        #instructions-screen h1 {
            margin-bottom: 40px;
            text-align: center;
        }

        #instructions-screen h3 {
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px currentColor;
            font-size: 18px;
        }

        #instructions-screen ul {
            line-height: 2;
            font-family: 'JetBrains Mono', monospace;
            padding-left: 30px;
        }

        #instructions-screen li {
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.9);
        }

        #instructions-screen strong {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #instructions-screen .button-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div id="lives">LIVES: 5</div>
        <div id="powerup-status"></div>
        <div id="score">SCORE: 0</div>
        <div id="dash-status" class="ready">DASH READY</div>
        <div id="shield-status" class="ready">🛡️ SHIELD READY</div>
        <div id="decoy-status" class="ready" style="display: none;">🐒 DECOY READY</div>
        <div id="level-display">CHAPTER 1 - LEVEL 1</div>
        <div id="timer">TIME: 120</div>
    </div>

    <!-- Add this new home screen before the chapter-select-screen -->
    <div id="home-screen" class="modal">
        <h1 style="font-size: 48px; margin-bottom: 30px;">3D PAC-MAN</h1>
        <p style="font-size: 14px; margin-bottom: 40px;">Experience the classic game in stunning 3D!</p>
        
        <div style="display: flex; flex-direction: column; gap: 20px; align-items: center;">
            <button id="start-game-home-button" 
                    onclick="startGameFromHome(); showChapterSelect();" 
                    onmousedown="this.onclick()" 
                    style="font-size: 28px; padding: 20px 40px; cursor: pointer;">START GAME</button>
            <button id="settings-button" style="font-size: 24px; padding: 15px 30px;">SETTINGS</button>
            <button id="instructions-button" style="font-size: 20px; padding: 12px 25px;">HOW TO PLAY</button>
        </div>
    </div>

    <!-- Add settings screen -->
    <div id="settings-screen" class="modal" style="display: none;">
        <h1>SETTINGS</h1>
        
        <div style="text-align: left; max-width: 500px; margin: 0 auto;">
            <!-- Music Settings -->
            <div style="margin-bottom: 40px; padding: 30px; background: rgba(0, 255, 255, 0.05); backdrop-filter: blur(10px); border: 3px solid; border-image: linear-gradient(45deg, #00ffff, #0080ff) 1; border-radius: 20px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);">
                <h3 style="color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 15px #00ffff;">🔊 AUDIO SETTINGS</h3>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 12px;">Master Volume:</label>
                    <input type="range" id="master-volume" min="0" max="100" value="50" style="width: 100%;">
                    <span id="master-volume-display" style="font-size: 10px; color: #ccc;">50%</span>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 12px;">Sound Effects:</label>
                    <input type="range" id="sfx-volume" min="0" max="100" value="70" style="width: 100%;">
                    <span id="sfx-volume-display" style="font-size: 10px; color: #ccc;">70%</span>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px;">
                        <input type="checkbox" id="mute-audio" style="margin-right: 8px;"> Mute All Audio
                    </label>
                </div>
            </div>

            <!-- Gameplay Settings -->
            <div style="margin-bottom: 40px; padding: 30px; background: rgba(0, 255, 0, 0.05); backdrop-filter: blur(10px); border: 3px solid; border-image: linear-gradient(45deg, #00ff88, #00ff00) 1; border-radius: 20px; box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);">
                <h3 style="color: #00ff88; margin-bottom: 20px; text-shadow: 0 0 15px #00ff88;">🎮 GAMEPLAY SETTINGS</h3>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 12px;">Game Difficulty:</label>
                    <select id="difficulty-select" style="width: 100%; padding: 5px; font-family: inherit; font-size: 10px;">
                        <option value="easy">Easy (Slower Ghosts)</option>
                        <option value="normal" selected>Normal</option>
                        <option value="hard">Hard (Faster Ghosts)</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 12px;">Camera Style:</label>
                    <select id="camera-select" style="width: 100%; padding: 5px; font-family: inherit; font-size: 10px;">
                        <option value="follow" selected>Follow Player</option>
                        <option value="fixed">Fixed Position</option>
                        <option value="smooth">Smooth Follow</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px;">
                        <input type="checkbox" id="show-fps" style="margin-right: 8px;"> Show FPS Counter
                    </label>
                </div>
            </div>

            <!-- Graphics Settings -->
            <div style="margin-bottom: 40px; padding: 30px; background: rgba(255, 0, 255, 0.05); backdrop-filter: blur(10px); border: 3px solid; border-image: linear-gradient(45deg, #ff00ff, #ff0080) 1; border-radius: 20px; box-shadow: 0 0 30px rgba(255, 0, 255, 0.2);">
                <h3 style="color: #ff00ff; margin-bottom: 20px; text-shadow: 0 0 15px #ff00ff;">🎨 GRAPHICS SETTINGS</h3>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 12px;">Graphics Quality:</label>
                    <select id="quality-select" style="width: 100%; padding: 5px; font-family: inherit; font-size: 10px;">
                        <option value="low">Low (Better Performance)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High (Better Visuals)</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px;">
                        <input type="checkbox" id="enable-shadows" checked style="margin-right: 8px;"> Enable Shadows
                    </label>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px;">
                        <input type="checkbox" id="enable-particles" checked style="margin-right: 8px;"> Enable Particle Effects
                    </label>
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
            <button id="save-settings-button">SAVE SETTINGS</button>
            <button id="reset-settings-button" style="background: #888; color: #fff;">RESET DEFAULTS</button>
            <button id="back-to-home-button" style="background: #f44; color: #fff;">BACK</button>
        </div>
    </div>

    <!-- Add instructions screen -->
    <div id="instructions-screen" class="modal" style="display: none;">
        <h1>HOW TO PLAY</h1>
        
        <div style="text-align: left; max-width: 500px; margin: 0 auto; font-size: 11px;">
            <div style="margin-bottom: 20px;">
                <h3 style="color: #ff0;">🎯 OBJECTIVE:</h3>
                <p>Navigate through the 3D maze, collect pellets and powerups while avoiding ghosts. Reach the target score to complete each level!</p>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #0f0;">🕹️ CONTROLS:</h3>
                <ul style="line-height: 1.6;">
                    <li><strong>Arrow Keys</strong> or <strong>WASD</strong> - Move Pac-Man</li>
                    <li><strong>Enter</strong> - Skip tutorial screens</li>
                    <li><strong>Escape</strong> - Quick skip/back</li>
                </ul>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #f0f;">⚡ POWERUPS:</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div>🛡️ <strong>Shield</strong> - Protection from ghosts</div>
                    <div>⚡ <strong>Speed</strong> - Move faster temporarily</div>
                    <div>💰 <strong>50 Points</strong> - Instant score boost</div>
                    <div>💎 <strong>100 Points</strong> - Big score boost</div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #0ff;">🎮 GAMEPLAY TIPS:</h3>
                <ul style="line-height: 1.6;">
                    <li>Eat power pellets to make ghosts frightened and edible</li>
                    <li>Each ghost gives increasing points when eaten (2000, 2500, 3000...)</li>
                    <li>Use powerups strategically to reach target scores</li>
                    <li>Complete levels quickly with no deaths for 3-star ratings</li>
                </ul>
            </div>
        </div>
        
        <button id="back-to-home-from-instructions-button">BACK TO MENU</button>
    </div>

    <!-- Hide chapter select initially and show home screen -->
    <div id="chapter-select-screen" class="modal" style="display: none;">
        <h1>SELECT CHAPTER</h1>
        <div id="chapter-select-container">
            <button class="chapter-button" data-chapter="0">Chapter 1</button>
            <button class="chapter-button" data-chapter="1">Chapter 2</button>
            <button class="chapter-button" data-chapter="2">Chapter 3</button>
        </div>
        <button id="back-to-home-from-chapters-button">BACK TO MENU</button>
    </div>

    <div id="level-select-screen" class="modal" style="display: none;">
        <h1 id="chapter-title">Chapter 1</h1>
        <p>You have 5 lives for your run.<br>Select a level to start.</p>
        <div id="level-select-container">
            <button class="level-button" data-level="0">Level 1</button>
            <button class="level-button" data-level="1">Level 2</button>
            <button class="level-button" data-level="2">Level 3</button>
            <button class="level-button" data-level="3">Level 4</button>
            <button class="level-button" data-level="4">Level 5</button>
        </div>
        <button id="back-to-chapters-button">Back to Chapters</button>
    </div>

    <div id="powerup-tutorial-screen" class="modal" style="display: none;">
        <h1>POWERUP GUIDE</h1>
        <p>Special powerups scattered in the maze:</p>

        <div class="powerup-grid">
            <div class="powerup-item" style="border: 2px solid #00ff00;">
                <div style="color: #00ff00; font-size: 16px; margin-bottom: 3px;">🛡️</div>
                <h3 style="color: #00ff00;">SHIELD</h3>
                <p>Protects from ONE ghost hit for 10s. Hit ghost becomes frightened!</p>
            </div>

            <div class="powerup-item" style="border: 2px solid #ff4400;">
                <div style="color: #ff4400; font-size: 16px; margin-bottom: 3px;">⚡</div>
                <h3 style="color: #ff4400;">SPEED BOOST</h3>
                <p>+50% speed for 8s. Great for escaping ghosts!</p>
            </div>

            <div class="powerup-item" style="border: 2px solid #ffff00;">
                <div style="color: #ffff00; font-size: 16px; margin-bottom: 3px;">💰</div>
                <h3 style="color: #ffff00;">50 POINTS</h3>
                <p>Instant 50 points toward your target score!</p>
            </div>

            <div class="powerup-item" style="border: 2px solid #ff00ff;">
                <div style="color: #ff00ff; font-size: 16px; margin-bottom: 3px;">💎</div>
                <h3 style="color: #ff00ff;">100 POINTS</h3>
                <p>Instant 100 points - very valuable!</p>
            </div>
        </div>

        <div class="tips-section">
            <h3 style="color: #ff0;">💡 TIPS:</h3>
            <ul style="text-align: left;">
                <li>Powerups spawn randomly in empty spaces</li>
                <li>Use shields when surrounded by ghosts</li>
                <li>Speed boosts help collect pellets quickly</li>
                <li>Powerups rotate and float - easy to spot!</li>
            </ul>
        </div>

        <p style="font-size: 20px; margin: 25px 0; font-family: 'JetBrains Mono', monospace; font-weight: 600;">
            <strong style="color: #00ffff; text-shadow: 0 0 10px #00ffff;">Target: <span id="tutorial-target-score">2000</span> points</strong><br>
            <span style="color: #ffff00; text-shadow: 0 0 10px #ffff00;">Use arrow keys or WASD to move!</span>
        </p>

        <div class="button-container">
            <button id="start-game-button">START GAME</button>
            <button id="skip-tutorial-button" style="background: #888; color: #fff;">SKIP TUTORIAL</button>
        </div>
    </div>

    <!-- Chapter 2 Powerup Tutorial Screen -->
    <div id="powerup-tutorial-2-screen" class="modal" style="display: none;">
        <h1>ICE POWERUPS GUIDE</h1>
        <p>Master the frozen maze with these specialized ice powerups:</p>

        <div class="powerup-grid">
            <div class="powerup-item" style="border: 2px solid #87ceeb;">
                <div style="color: #87ceeb; font-size: 16px; margin-bottom: 3px;">🧊</div>
                <h3 style="color: #87ceeb;">ICE WALL</h3>
                <p>Press <strong>SPACEBAR</strong> to place ice blocks that stop ghosts! Blocks last 4 seconds.</p>
            </div>

            <div class="powerup-item" style="border: 2px solid #b0e0e6;">
                <div style="color: #b0e0e6; font-size: 16px; margin-bottom: 3px;">❄️</div>
                <h3 style="color: #b0e0e6;">FLASH FREEZE</h3>
                <p>Creates a frost aura that slows ghosts by 50% for 5 seconds. Perfect for escaping!</p>
            </div>

            <div class="powerup-item" style="border: 2px solid #f0f8ff;">
                <div style="color: #f0f8ff; font-size: 16px; margin-bottom: 3px;">🥾</div>
                <h3 style="color: #f0f8ff;">ICE CLEATS</h3>
                <p>Perfect traction for 6 seconds! No more slipping on ice - move with precision!</p>
            </div>

            <div class="powerup-item" style="border: 2px solid #708090;">
                <div style="color: #708090; font-size: 16px; margin-bottom: 3px;">⚠️</div>
                <h3 style="color: #708090;">ICE PHYSICS</h3>
                <p>The maze floor is slippery! Momentum carries you forward - plan your moves carefully!</p>
            </div>
        </div>

        <div class="tips-section">
            <h3 style="color: #87ceeb;">❄️ SURVIVAL TIPS:</h3>
            <ul style="text-align: left;">
                <li>Ice makes movement slippery - plan your routes carefully</li>
                <li>Use Ice Walls to create safe passages and trap ghosts</li>
                <li>Flash Freeze works best in tight corners</li>
                <li>Ice Cleats are perfect for precise pellet collection</li>
                <li>Don't stand on cracked floors too long - they break after 1 second!</li>
                <li>Press J to jump out if you fall into a hole</li>
                <li>Ghosts can still fall into holes you create for bonus points</li>
                <li>Watch for the white aura - it shows your traction effect!</li>
            </ul>
        </div>

        <p style="font-size: 20px; margin: 25px 0; font-family: 'JetBrains Mono', monospace; font-weight: 600;">
            <strong style="color: #87ceeb; text-shadow: 0 0 10px #87ceeb;">Target: <span id="tutorial-2-target-score">2000</span> points</strong><br>
            <span style="color: #b0e0e6; text-shadow: 0 0 10px #b0e0e6;">Survive the icy maze and collect all pellets!</span>
        </p>

        <div class="button-container">
            <button id="start-game-2-button">START FROZEN MAZE</button>
            <button id="skip-tutorial-2-button" style="background: #888; color: #fff;">SKIP TUTORIAL</button>
        </div>
    </div>

    <!-- Chapter 1 Controls Tutorial Screen -->
    <div id="controls-tutorial-screen" class="modal" style="display: none;">
        <h1>GAME CONTROLS</h1>
        <p>Master these controls to survive the maze and collect all pellets:</p>

        <div class="controls-grid">
            <div class="control-item" style="border: 2px solid #00ff00;">
                <h3 style="color: #00ff00;">MOVEMENT</h3>
                <div>
                    <span class="key-display" style="color: #00ff00;">W</span>
                    <span class="key-display" style="color: #00ff00;">A</span>
                    <span class="key-display" style="color: #00ff00;">S</span>
                    <span class="key-display" style="color: #00ff00;">D</span>
                </div>
                <p>OR</p>
                <div>
                    <span class="key-display" style="color: #00ff00;">↑</span>
                    <span class="key-display" style="color: #00ff00;">←</span>
                    <span class="key-display" style="color: #00ff00;">↓</span>
                    <span class="key-display" style="color: #00ff00;">→</span>
                </div>
                <p>Navigate through the maze and avoid ghosts!</p>
            </div>

            <div class="control-item" style="border: 2px solid #ffff00;">
                <h3 style="color: #ffff00;">ADRENALINE DASH</h3>
                <div>
                    <span class="key-display" style="color: #ffff00;">SHIFT</span>
                </div>
                <p>Double your speed for 4 seconds! Perfect for escaping ghosts or collecting pellets quickly.</p>
                <p style="color: #ff8800; font-size: 12px;">Cooldown: 10 seconds</p>
            </div>

            <div class="control-item" style="border: 2px solid #00ffff;">
                <h3 style="color: #00ffff;">ENERGY SHIELD</h3>
                <div>
                    <span class="key-display" style="color: #00ffff;">E</span>
                </div>
                <p>Activate a protective shield for 2 seconds! Shield breaks on ghost contact but stuns the ghost.</p>
                <p style="color: #ff8800; font-size: 12px;">Cooldown: 15 seconds</p>
            </div>

            <div class="control-item" style="border: 2px solid #ff00ff;">
                <h3 style="color: #ff00ff;">OBJECTIVE</h3>
                <div style="font-size: 24px; margin: 10px 0;">🟡</div>
                <p>Collect all yellow pellets to complete the level. Avoid the colorful ghosts!</p>
                <p style="color: #00ffff;">Power pellets make ghosts vulnerable temporarily.</p>
            </div>

            <div class="control-item" style="border: 2px solid #ff4400;">
                <h3 style="color: #ff4400;">POWERUPS</h3>
                <div style="font-size: 24px; margin: 10px 0;">⚡🛡️💰💎</div>
                <p>Collect rotating powerups for special abilities: speed boosts, shields, and bonus points!</p>
                <p style="color: #00ff88;">They spawn randomly in empty spaces.</p>
            </div>
        </div>

        <div class="tips-section">
            <h3>💡 SURVIVAL TIPS:</h3>
            <ul>
                <li>Plan your routes - ghosts move strategically!</li>
                <li>Use dash to escape tight situations</li>
                <li>Use Energy Shield (E) as emergency protection</li>
                <li>Collect powerups before they disappear</li>
                <li>Watch the timer - complete objectives quickly!</li>
                <li>Use corners to your advantage</li>
                <li>Power pellets are your best friend against ghosts</li>
            </ul>
        </div>

        <div class="button-container">
            <button id="start-game-from-controls">I UNDERSTOOD</button>
        </div>
    </div>

    <!-- Chapter 2 Controls Tutorial Screen -->
    <div id="controls-tutorial-2-screen" class="modal" style="display: none;">
        <div class="modal-content">
            <h1>ICE MAZE CONTROLS</h1>
            <p>Master the frozen maze with these essential controls and mechanics:</p>

            <div class="controls-grid">
                <div class="control-item" style="border: 2px solid #87ceeb;">
                    <h3 style="color: #87ceeb;">MOVEMENT</h3>
                    <div>
                        <span class="key-display" style="color: #87ceeb;">W</span>
                        <span class="key-display" style="color: #87ceeb;">A</span>
                        <span class="key-display" style="color: #87ceeb;">S</span>
                        <span class="key-display" style="color: #87ceeb;">D</span>
                    </div>
                    <p style="color: #ff6600; font-weight: bold;">⚠️ ICE PHYSICS ACTIVE!</p>
                    <p>Movement is slippery - momentum carries you forward. Plan your moves carefully!</p>
                </div>

                <div class="control-item" style="border: 2px solid #b0e0e6;">
                    <h3 style="color: #b0e0e6;">ICE WALL PLACEMENT</h3>
                    <div>
                        <span class="key-display" style="color: #b0e0e6;">SPACEBAR</span>
                    </div>
                    <p>Place ice blocks to create barriers! Blocks last 4 seconds and can trap ghosts.</p>
                    <p style="color: #ffff00; font-size: 12px;">Requires Ice Wall powerup charges</p>
                </div>

                <div class="control-item" style="border: 2px solid #ffff00;">
                    <h3 style="color: #ffff00;">ADRENALINE DASH</h3>
                    <div>
                        <span class="key-display" style="color: #ffff00;">SHIFT</span>
                    </div>
                    <p>Double speed for 4 seconds! Essential for navigating icy terrain safely.</p>
                    <p style="color: #ff8800; font-size: 12px;">Cooldown: 10 seconds</p>
                </div>

                <div class="control-item" style="border: 2px solid #00ffff;">
                    <h3 style="color: #00ffff;">ENERGY SHIELD</h3>
                    <div>
                        <span class="key-display" style="color: #00ffff;">E</span>
                    </div>
                    <p>Protective shield for 2 seconds! Breaks on ghost contact, stuns ghost, and pushes them back.</p>
                    <p style="color: #ff8800; font-size: 12px;">Cooldown: 15 seconds</p>
                </div>

                <div class="control-item" style="border: 2px solid #ff4444;">
                    <h3 style="color: #ff4444;">ESCAPE HOLES</h3>
                    <div>
                        <span class="key-display" style="color: #ff4444;">J</span>
                    </div>
                    <p>Jump out if you fall into a cracked floor hole! Don't get stuck!</p>
                    <p style="color: #00ff88; font-size: 12px;">Ghosts can also fall into holes for bonus points</p>
                </div>
            </div>

            <div class="tips-section">
                <h3>❄️ ICE SURVIVAL GUIDE:</h3>
                <ul>
                    <li>Ice floors make you slide - use momentum strategically</li>
                    <li>Ice Cleats powerup gives perfect traction temporarily</li>
                    <li>Flash Freeze creates an aura that slows nearby ghosts</li>
                    <li>Energy Shield (E) is crucial for survival on slippery ice</li>
                    <li>Don't stand on cracked floors too long - they break!</li>
                    <li>Use Ice Walls to create safe passages and escape routes</li>
                    <li>Watch for the white traction aura when cleats are active</li>
                    <li>Dash is extra useful for precise movement on ice</li>
                    <li>Plan your route before moving - ice physics are unforgiving!</li>
                </ul>
            </div>

            <div class="button-container">
                <button id="start-game-from-controls-2">I UNDERSTOOD</button>
            </div>
        </div>
    </div>

    <!-- Chapter 3 Power-ups Tutorial Screen -->
    <div id="chapter3-powerups-screen" class="modal" style="display: none;">
        <div class="modal-content">
            <h1 style="color: #2ecc71; text-align: center; margin-bottom: 30px;">🌿 CHAPTER 3: JUNGLE RUINS 🌿</h1>
            <h2 style="color: #8b4513; text-align: center; margin-bottom: 25px;">NEW POWER-UPS & ABILITIES</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
                <!-- Snare Seed -->
                <div style="background: linear-gradient(135deg, #2c5530, #1a3a1f); padding: 20px; border-radius: 15px; border: 2px solid #32cd32;">
                    <h3 style="color: #8b4513; margin-bottom: 15px; text-align: center;">🌱 SNARE SEED</h3>
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div style="font-size: 48px; margin-bottom: 10px;">🌱</div>
                        <p style="color: #32cd32; font-size: 12px;">Collect from green powerups</p>
                    </div>
                    <ul style="color: #90EE90; font-size: 14px; text-align: left;">
                        <li>Press F to place vine traps</li>
                        <li>Entangles ghosts for 3.5 seconds</li>
                        <li>Trapped ghosts turn green and can't move</li>
                        <li>Earn 200 points per trapped ghost</li>
                    </ul>
                </div>
                
                <!-- Monkey Decoy -->
                <div style="background: linear-gradient(135deg, #8b4513, #654321); padding: 20px; border-radius: 15px; border: 2px solid #ffd700;">
                    <h3 style="color: #ffd700; margin-bottom: 15px; text-align: center;">🐒 MONKEY DECOY</h3>
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div style="font-size: 48px; margin-bottom: 10px;">🐒</div>
                        <p style="color: #daa520; font-size: 12px;">Collect Golden Monkey Idols</p>
                    </div>
                    <ul style="color: #daa520; font-size: 14px; text-align: left;">
                        <li>Press F to deploy active decoy</li>
                        <li>ALL ghosts chase the decoy instead of you!</li>
                        <li>Lasts for 5 seconds</li>
                        <li>Perfect for escaping dangerous situations</li>
                    </ul>
                </div>
            </div>
            
            <!-- Strategy Tips -->
            <div style="background: linear-gradient(135deg, #4a5d23, #3a4a1c); padding: 20px; border-radius: 15px; border: 2px solid #9acd32; margin-bottom: 30px;">
                <h3 style="color: #9acd32; margin-bottom: 15px; text-align: center;">🧠 STRATEGY TIPS</h3>
                <ul style="color: #adff2f; font-size: 14px; text-align: left;">
                    <li><strong>Combo Strategy:</strong> Use Snare Seeds to trap pursuers, then deploy Monkey Decoy to distract remaining ghosts</li>
                    <li><strong>Escape Plan:</strong> Monkey Decoy is perfect for getting out of corners or surrounded situations</li>
                    <li><strong>Resource Management:</strong> Save decoys for emergency situations - they're rare!</li>
                    <li><strong>Timing:</strong> Deploy decoys when multiple ghosts are chasing you for maximum effectiveness</li>
                </ul>
            </div>
            
            <div style="text-align: center;">
                <button onclick="showChapter3Controls()" 
                        style="padding: 15px 30px; font-size: 18px; background: linear-gradient(45deg, #2ecc71, #27ae60); 
                               color: white; border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
                    CONTINUE TO CONTROLS →
                </button>
            </div>
        </div>
    </div>

    <!-- Chapter 3 Controls Tutorial Screen -->
    <div id="controls-tutorial-3-screen" class="modal" style="display: none;">
        <div class="modal-content">
            <h1>JUNGLE RUINS CONTROLS</h1>
            <p>Survive the ancient jungle ruins with enhanced ghost AI and crumbling environments:</p>

            <div class="controls-grid">
            <div class="control-item" style="border: 2px solid #8B4513;">
                <h3 style="color: #8B4513;">MOVEMENT</h3>
                <div>
                    <span class="key-display" style="color: #8B4513;">W</span>
                    <span class="key-display" style="color: #8B4513;">A</span>
                    <span class="key-display" style="color: #8B4513;">S</span>
                    <span class="key-display" style="color: #8B4513;">D</span>
                </div>
                <p style="color: #ff6600; font-weight: bold;">⚠️ ENHANCED GHOST AI!</p>
                <p>Ghosts predict your movements and use advanced pathfinding. Stay alert!</p>
            </div>

            <div class="control-item" style="border: 2px solid #ffff00;">
                <h3 style="color: #ffff00;">ADRENALINE DASH</h3>
                <div>
                    <span class="key-display" style="color: #ffff00;">SHIFT</span>
                </div>
                <p>Essential for escaping smarter ghosts! Double speed for 4 seconds.</p>
                <p style="color: #ff8800; font-size: 12px;">Cooldown: 10 seconds</p>
            </div>

            <div class="control-item" style="border: 2px solid #00ffff;">
                <h3 style="color: #00ffff;">ENERGY SHIELD</h3>
                <div>
                    <span class="key-display" style="color: #00ffff;">E</span>
                </div>
                <p>Critical survival tool! Breaks on contact, stuns and pushes back attacking ghost.</p>
                <p style="color: #ff8800; font-size: 12px;">Cooldown: 15 seconds</p>
            </div>
        </div>

        <div class="tips-section">
            <h3>🌿 JUNGLE SURVIVAL GUIDE:</h3>
            <ul>
                <li>Ghosts use predictive AI - vary your movement patterns</li>
                <li>Energy Shield (E) is your primary defense against smart ghosts</li>
                <li>Dash frequently to break ghost tracking algorithms</li>
                <li>Collect Snare Seed powerups to get trap charges</li>
                <li>Use Snare Seeds (F) strategically to trap pursuing ghosts</li>
                <li>Trapped ghosts can still kill you if you touch them!</li>
                <li>Place traps behind you when being chased</li>
                <li>Crumbling walls create new routes but also new dangers</li>
                <li>Vines limit visibility - rely on sound and movement cues</li>
                <li>Faster ghost speeds require faster decision making</li>
                <li>Use corners and maze knowledge to your advantage</li>
                <li>Plan escape routes before entering dangerous areas</li>
            </ul>
        </div>

            <div class="button-container">
                <button id="start-game-from-controls-3">I UNDERSTOOD</button>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="modal" style="display: none;">
        <h1 id="game-over-title">GAME OVER</h1>
        <p id="final-score">You lost all your lives.</p>
        <button id="restart-button">LEVEL SELECT</button>
    </div>

    <div id="level-complete-screen" class="modal" style="display: none;">
        <h1 id="level-complete-title">LEVEL COMPLETE!</h1>
        <div id="performance-stars" class="stars">★★★</div>
        <p id="level-complete-stats">Time: 45.2s<br>Lives Lost: 0</p>
        <div id="advantage-choices" class="choice-container" style="display: none;">
            <p>Choose your reward:</p>
            <button id="increase-speed-button">+10% Player Speed</button>
            <button id="extra-life-button">+1 Extra Life</button>
            <button id="choose-powerup-button">Choose Starting Powerup</button>
        </div>
        <div id="sacrifice-choices" class="choice-container" style="display: none;">
            <p>Good performance! Choose your sacrifice to proceed:</p>
            <button id="sacrifice-speed-button">-5% Player Speed</button>
            <button id="sacrifice-time-button">-10 Seconds Next Level</button>
            <button id="sacrifice-score-button">+10% Target Score</button>
            <button id="sacrifice-powerup-duration-button">Shorter Powerup Effects</button>
        </div>
        <div id="disadvantage-choices" class="choice-container" style="display: none;">
            <p>Choose your penalty:</p>
            <button id="lose-life-button">-1 Life</button>
            <button id="decrease-speed-button">-10% Player Speed</button>
            <button id="increase-ghost-speed-button">+10% Ghost Speed</button>
            <button id="no-powerups-button">No Powerups Next Level</button>
        </div>
        <button id="level-menu-button">Level Select</button>
    </div>

    <div id="chapter-complete-screen" class="modal" style="display: none;">
        <h1>CHAPTER COMPLETE!</h1>
        <p id="chapter-complete-score">Your Final Score: 0</p>
        <button id="back-to-menu-button">CHAPTER SELECT</button>
    </div>

    <!-- Powerup Selection Modal -->
    <div id="powerup-selection-screen" class="modal" style="display: none;">
        <h1>CHOOSE YOUR POWERUP</h1>
        <p>Select a powerup to start the next level with:</p>
        
        <div class="powerup-grid">
            <div class="powerup-item" style="border: 2px solid #00ff00;">
                <div style="color: #00ff00; font-size: 32px; margin-bottom: 10px;">🛡️</div>
                <h3 style="color: #00ff00;">SHIELD</h3>
                <p>Start with shield protection active</p>
                <button class="select-powerup-button" data-powerup="SHIELD">SELECT</button>
            </div>

            <div class="powerup-item" style="border: 2px solid #ff4400;">
                <div style="color: #ff4400; font-size: 32px; margin-bottom: 10px;">⚡</div>
                <h3 style="color: #ff4400;">SPEED BOOST</h3>
                <p>Start with speed boost active</p>
                <button class="select-powerup-button" data-powerup="SPEED">SELECT</button>
            </div>

            <div class="powerup-item" style="border: 2px solid #ffff00;">
                <div style="color: #ffff00; font-size: 32px; margin-bottom: 10px;">💰</div>
                <h3 style="color: #ffff00;">50 POINTS</h3>
                <p>Start with extra 50 points</p>
                <button class="select-powerup-button" data-powerup="POINTS_50">SELECT</button>
            </div>

            <div class="powerup-item" style="border: 2px solid #ff00ff;">
                <div style="color: #ff00ff; font-size: 32px; margin-bottom: 10px;">💎</div>
                <h3 style="color: #ff00ff;">100 POINTS</h3>
                <p>Start with extra 100 points</p>
                <button class="select-powerup-button" data-powerup="POINTS_100">SELECT</button>
            </div>
        </div>
        
        <button id="cancel-powerup-selection">CANCEL</button>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap"> 
        { 
            "imports": { 
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", 
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" 
            } 
        } 
    </script>
    
    <!-- Essential navigation functions - must be in regular script tag for HTML onclick access -->
    <script>
        // ESSENTIAL NAVIGATION FUNCTIONS - MUST BE GLOBAL!
        function startGameFromHome() {
            console.log('startGameFromHome function called!');
            try {
                const home = document.getElementById('home-screen');
                const chapterSelect = document.getElementById('chapter-select-screen');
                
                if (home && chapterSelect) {
                    home.style.display = 'none';
                    chapterSelect.style.display = 'block';
                    console.log('Successfully navigated to chapter select screen');
                } else {
                    console.error('Could not find screen elements');
                    // Fallback method
                    document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
                    document.getElementById('chapter-select-screen').style.display = 'block';
                }
            } catch (error) {
                console.error('Error in startGameFromHome:', error);
            }
        }

        // Alternative universal function that definitely works
        function showChapterSelect() {
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById('chapter-select-screen').style.display = 'block';
        }
        
        // Chapter 3 Power-ups Tutorial Functions
        function showChapter3Powerups() {
            console.log('Showing Chapter 3 power-ups tutorial...');
            // Hide all screens
            document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
            document.getElementById('chapter3-powerups-screen').style.display = 'block';
        }
        
        function showChapter3Controls() {
            console.log('Proceeding to Chapter 3 controls...');
            // Hide all screens and show Chapter 3 controls tutorial
            document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
            document.getElementById('controls-tutorial-3-screen').style.display = 'flex';
        }
        
        // Make functions globally available for HTML event handlers
        window.startGameFromHome = startGameFromHome;
        window.showChapterSelect = showChapterSelect;
        window.showChapter3Powerups = showChapter3Powerups;
        window.showChapter3Controls = showChapter3Controls;
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        
        // Load Tone.js with error handling
        try {
            await import("https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js");
        } catch (error) {
            console.warn('Tone.js failed to load, audio will be disabled:', error);
            // Create dummy Tone object to prevent errors
            window.Tone = {
                start: () => Promise.resolve(),
                PolySynth: function() { return { toDestination: () => this }; },
                Synth: function() {},
                now: () => 0
            };
        }

        // --- SCENE & RENDERER ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        const clock = new THREE.Clock();

        // Simple message display function
        function showMessage(message, duration = 2000) {
            // Create or get existing message element
            let messageElement = document.getElementById('game-message');
            if (!messageElement) {
                messageElement = document.createElement('div');
                messageElement.id = 'game-message';
                messageElement.style.cssText = `
                    position: fixed;
                    top: 20%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #ffffff;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 16px;
                    font-weight: bold;
                    text-align: center;
                    z-index: 1000;
                    border: 2px solid #00ffff;
                    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(messageElement);
            }
            
            // Show message
            messageElement.textContent = message;
            messageElement.style.opacity = '1';
            
            // Hide after duration
            setTimeout(() => {
                messageElement.style.opacity = '0';
            }, duration);
        }

        // --- AUDIO ---
        let synth, sounds;
        try {
            synth = new Tone.PolySynth({
                voice: Tone.Synth,
                maxPolyphony: 4 // Limit to 4 voices to prevent polyphony exceeded error
            }).toDestination();
            
            sounds = {
                pellet: () => { try { synth.triggerAttackRelease("C5", "8n", Tone.now()); } catch(e) {} },
                powerPellet: () => { try { synth.triggerAttackRelease("G5", "8n", Tone.now()); } catch(e) {} },
                death: () => { try { synth.triggerAttackRelease(["C4", "G3"], "2n", Tone.now()); } catch(e) {} },
                eatGhost: () => { try { synth.triggerAttackRelease("A5", "8n", Tone.now()); } catch(e) {} },
                win: () => { try { synth.triggerAttackRelease(["C4", "E4"], "1n", Tone.now()); } catch(e) {} },
                levelUp: () => { try { synth.triggerAttackRelease(["C5", "E5"], "0.5n", Tone.now()); } catch(e) {} },
                dash: () => { try { synth.triggerAttackRelease("F5", "4n", Tone.now()); } catch(e) {} },
                shieldActivate: () => { try { synth.triggerAttackRelease("E5", "4n", Tone.now()); } catch(e) {} },
                shieldBreak: () => { try { synth.triggerAttackRelease("D5", "4n", Tone.now()); } catch(e) {} },
                shieldDeactivate: () => { try { synth.triggerAttackRelease("B4", "8n", Tone.now()); } catch(e) {} }
            };
        } catch (error) {
            console.warn('Audio initialization failed, using silent sounds:', error);
            sounds = {
                pellet: () => {},
                powerPellet: () => {},
                death: () => {},
                eatGhost: () => {},
                win: () => {},
                levelUp: () => {},
                dash: () => {},
                shieldActivate: () => {},
                shieldBreak: () => {},
                shieldDeactivate: () => {}
            };
        }

        // --- GAME STATE ---
        const TILE_SIZE = 2;
        
        const BASE_PLAYER_SPEED = 3;
        let playerSpeed = BASE_PLAYER_SPEED;
        let ghostSpeedModifier = 1.0;
        let player, mazeObjects = new THREE.Group(), ghosts = [], pellets = [], powerPellets = [];
        let score = 0, lives = 5, scoreAtLevelStart = 0, livesAtLevelStart = 0;
        let currentChapterIndex = 0, currentLevelIndexInChapter = 0;
        let highestUnlockedLevel = 1;
        let gameOver = true, gameStarted = false;
        let powerUpTimer = 0, levelTimer = 0;
        let powerups = []; // Add this line for powerups array
        let playerShield = false, shieldTimer = 0; // Add shield system
        
        // Energy Shield System
        let isShieldActive = false; // Is the shield currently on?
        let shieldDuration = 0; // Countdown timer for how long shield stays active (2 seconds)
        let shieldCooldown = 0; // Countdown timer for when you can use shield again (15 seconds)
        let shieldObject = null; // Visual shield geometry around player
        const SHIELD_DURATION_TIME = 2; // 2 seconds of protection
        const SHIELD_COOLDOWN_TIME = 15; // 15 seconds cooldown
        
        let iceWallCharges = 0; // Ice wall charges for Chapter 2
        let temporaryIceBlocks = []; // Track temporary ice blocks
        let flashFreezeActive = false; // Flash freeze aura state
        let flashFreezeTimer = 0; // Flash freeze duration timer
        let frostAura = null; // Visual frost aura object
        let iceCleatsActive = false; // Ice cleats traction state
        let iceCleatsTimer = 0; // Ice cleats duration timer
        let tractionAura = null; // Visual traction aura object
        let selectedPowerupType = null; // For storing chosen powerup type
        let snareSeedCharges = 0; // Snare seed charges for Chapter 3
        let activeSnareSeedTraps = []; // Track active snare seed traps
        
        // 🐒 MONKEY DECOY POWER-UP SYSTEM
        let hasDecoy = false;           // Does player have a monkey decoy?
        let activeDecoy = null;         // Currently deployed decoy object
        let decoyTimer = 0;             // Time remaining for active decoy
        const DECOY_DURATION = 5000;    // 5 seconds in milliseconds
        const DECOY_SPEED = 2;           // Decoy movement speed (similar to player)
        let decoyDirection = { x: 0, z: 0 }; // Decoy movement direction
        let bonusFruit = null; // Current bonus fruit object
        let bonusFruitTimer = 0; // Time remaining for bonus fruit
        let bonusFruitSpawnTimer = 0; // Timer for spawning next bonus fruit
        let frozenFruit = null; // Frozen fruit for Chapter 2
        let frozenFruitTimer = 0; // Time remaining for frozen fruit
        let noPowerupsNextLevel = false; // For no powerups disadvantage
        let timeReductionNextLevel = 0; // For time sacrifice
        let targetScoreIncreaseNextLevel = 1.0; // For score sacrifice
        let powerupDurationReduction = 1.0; // For powerup duration sacrifice

        // Adrenaline Dash system
        let dashCooldown = 0; // Dash cooldown timer (in seconds)
        let dashActive = false; // Whether dash is currently active
        let dashTimer = 0; // Duration of current dash effect
        const DASH_COOLDOWN_DURATION = 10; // 10 seconds cooldown
        const DASH_EFFECT_DURATION = 4; // 4 seconds of speed boost
        const DASH_SPEED_MULTIPLIER = 2; // Double speed during dash
        let originalFOV = 75; // Store original camera FOV
        let dashParticles = []; // Array to store dash trail particles

        // Active powerups tracking system
        let activePowerups = new Map(); // Map to track multiple active powerups
        const powerupSymbols = {
            'shield': '🛡️',
            'speed': '⚡',
            'points_50': '💰',
            'points_100': '💎', 
            'ice_wall': '🧊',
            'flash_freeze': '❄️',
            'ice_cleats': '🥾',
            'snare_seed': '🌱'
        };

        // Add a powerup to the active list
        function addActivePowerup(type, duration) {
            const id = Date.now() + Math.random(); // Unique ID for each powerup instance
            activePowerups.set(id, {
                type: type,
                remainingTime: duration,
                maxDuration: duration,
                startTime: Date.now()
            });
            updatePowerupDisplay();
            return id;
        }

        // Remove a powerup from the active list
        function removeActivePowerup(id) {
            if (activePowerups.has(id)) {
                activePowerups.delete(id);
                updatePowerupDisplay();
            }
        }

        // Update the visual display of active powerups
        function updatePowerupDisplay() {
            const container = document.getElementById('powerup-status');
            container.innerHTML = '';
            
            activePowerups.forEach((powerup, id) => {
                const indicator = document.createElement('div');
                indicator.className = 'powerup-indicator';
                indicator.innerHTML = powerupSymbols[powerup.type] || '❓';
                
                // Create progress ring
                const progress = document.createElement('div');
                progress.className = 'powerup-progress';
                
                // Calculate progress percentage
                const progressPercent = (powerup.remainingTime / powerup.maxDuration) * 100;
                const rotation = (progressPercent / 100) * 360;
                progress.style.transform = `rotate(${rotation}deg)`;
                
                // Apply warning colors based on remaining time
                if (progressPercent <= 20) {
                    progress.classList.add('critical');
                } else if (progressPercent <= 40) {
                    progress.classList.add('warning');
                }
                
                indicator.appendChild(progress);
                container.appendChild(indicator);
            });
        }

        // Clear all active powerups (used when game resets)
        function clearAllActivePowerups() {
            activePowerups.clear();
            updatePowerupDisplay();
        }

        // Update powerup timers (called from game loop)
        function updateActivePowerups(deltaTime) {
            const toRemove = [];
            
            activePowerups.forEach((powerup, id) => {
                powerup.remainingTime -= deltaTime;
                
                if (powerup.remainingTime <= 0) {
                    toRemove.push(id);
                } else {
                    // Update display for this powerup
                    updatePowerupDisplay();
                }
            });
            
            // Remove expired powerups
            toRemove.forEach(id => removeActivePowerup(id));
        }

        // Ice mechanics for Chapter 2
        let isOnIce = false;
        let iceSlipDistance = 0;
        let iceSlipDirection = new THREE.Vector3();
        let iceTurnDelay = 0;
        const ICE_SLIP_FACTOR = 0.92; // Increased from 0.85 - momentum retained longer
        const ICE_TURN_DELAY = 5; // Reduced from 8 to 5 frames for better responsiveness
        const ICE_SLIP_THRESHOLD = 0.05; // Reduced from 0.1 - slip continues longer
        const ICE_INITIAL_SLIP = 4.5; // Increased from 3.0 - more initial momentum
        const ICE_MOMENTUM_BUILDUP = 0.15; // New - builds momentum while moving

        const chapters = [
            [
                { level: 1, ghostCount: 3, ghostSpeed: 2.0, powerUpDuration: 8, targetScore: 2000, timeLimit: 120 },
                { level: 2, ghostCount: 4, ghostSpeed: 2.2, powerUpDuration: 8, targetScore: 2500, timeLimit: 110 },
                { level: 3, ghostCount: 5, ghostSpeed: 2.4, powerUpDuration: 7, targetScore: 3000, timeLimit: 100 },
                { level: 4, ghostCount: 6, ghostSpeed: 2.6, powerUpDuration: 7, targetScore: 3500, timeLimit: 90 },
                { level: 5, ghostCount: 6, ghostSpeed: 2.8, powerUpDuration: 6, targetScore: 4000, timeLimit: 80 },
            ],
            [
                { level: 1, ghostCount: 4, ghostSpeed: 2.5, powerUpDuration: 7, targetScore: 3000, timeLimit: 100 },
                { level: 2, ghostCount: 5, ghostSpeed: 2.8, powerUpDuration: 7, targetScore: 3500, timeLimit: 95 },
                { level: 3, ghostCount: 6, ghostSpeed: 3.0, powerUpDuration: 6, targetScore: 4000, timeLimit: 90 },
                { level: 4, ghostCount: 7, ghostSpeed: 3.2, powerUpDuration: 6, targetScore: 4500, timeLimit: 85 },
                { level: 5, ghostCount: 8, ghostSpeed: 3.5, powerUpDuration: 5, targetScore: 5000, timeLimit: 80 },
            ],
            [
                { level: 1, ghostCount: 5, ghostSpeed: 3.0, powerUpDuration: 6, targetScore: 4000, timeLimit: 95 },
                { level: 2, ghostCount: 6, ghostSpeed: 3.3, powerUpDuration: 6, targetScore: 4500, timeLimit: 90 },
                { level: 3, ghostCount: 7, ghostSpeed: 3.6, powerUpDuration: 5, targetScore: 5000, timeLimit: 85 },
                { level: 4, ghostCount: 8, ghostSpeed: 3.9, powerUpDuration: 5, targetScore: 5500, timeLimit: 80 },
                { level: 5, ghostCount: 9, ghostSpeed: 4.2, powerUpDuration: 4, targetScore: 6000, timeLimit: 75 },
            ]
        ];

        // Add powerup types
        const POWERUP_TYPES = {
            shield: { color: 0x00ff00, points: 0, effect: 'shield', duration: 10 },
            speed: { color: 0xff4400, points: 0, effect: 'speed', duration: 8 },
            points_50: { color: 0xffff00, points: 50, effect: 'points', duration: 0 },
            points_100: { color: 0xff00ff, points: 100, effect: 'points', duration: 0 },
            ice_wall: { 
                color: 0x87ceeb, 
                points: 75, 
                effect: 'ice_wall', 
                duration: 0 // Instant use, gives one charge
            },
            flash_freeze: {
                color: 0xb0e0e6,
                points: 100,
                effect: 'flash_freeze',
                duration: 5000 // 5 seconds of frost aura
            },
            ice_cleats: {
                color: 0xf0f8ff,
                points: 125,
                effect: 'ice_cleats',
                duration: 6000 // 6 seconds of perfect traction
            },
            snare_seed: {
                color: 0x8b4513, // Brown seed pod color
                points: 150,
                effect: 'snare_seed',
                duration: 0 // Instant use, gives one charge
            }
        };

        // --- UI ELEMENTS ---
        const uiContainer = document.getElementById('ui-container');
        // DOM element references - will be initialized after DOM loads
        let scoreEl, livesEl, levelEl, timerEl;
        let chapterSelectScreen, levelSelectScreen, gameOverScreen, levelCompleteScreen, chapterCompleteScreen;
        let finalScoreEl, levelCompleteStatsEl, performanceStarsEl, chapterCompleteScoreEl;
        let advantageChoicesEl, sacrificeChoicesEl, disadvantageChoicesEl;
        const levelCompleteTitleEl = document.getElementById('level-complete-title');

        // Add the powerup tutorial screen elements
        const powerupTutorialScreen = document.getElementById('powerup-tutorial-screen');
        const powerupTutorial2Screen = document.getElementById('powerup-tutorial-2-screen');
        const controlsTutorialScreen = document.getElementById('controls-tutorial-screen');
        const controlsTutorial2Screen = document.getElementById('controls-tutorial-2-screen');
        const tutorialTargetScoreEl = document.getElementById('tutorial-target-score');
        const tutorial2TargetScoreEl = document.getElementById('tutorial-2-target-score');
        const startGameButton = document.getElementById('start-game-button');
        const skipTutorialButton = document.getElementById('skip-tutorial-button');
        const startGame2Button = document.getElementById('start-game-2-button');
        const skipTutorial2Button = document.getElementById('skip-tutorial-2-button');
        const startGameFromControlsButton = document.getElementById('start-game-from-controls');
        const startGameFromControls2Button = document.getElementById('start-game-from-controls-2');
        const startGameFromControls3Button = document.getElementById('start-game-from-controls-3');

        // Add new UI elements
        const homeScreen = document.getElementById('home-screen');
        const settingsScreen = document.getElementById('settings-screen');
        const instructionsScreen = document.getElementById('instructions-screen');

        // Settings variables
        let masterVolume = 0.5;
        let sfxVolume = 0.7;
        let audioMuted = false;
        let gameDifficulty = 'normal';
        let cameraStyle = 'follow';
        let showFPS = false;
        let graphicsQuality = 'medium';
        let shadowsEnabled = true;
        let particlesEnabled = true;

        // FPS counter
        let fpsCounter = null;
        let frameCount = 0;
        let lastTime = 0;

        // Update the audio setup to use volume settings
        const updateAudioVolume = () => {
            if (audioMuted) {
                Tone.Destination.volume.value = -Infinity;
            } else {
                Tone.Destination.volume.value = Tone.gainToDb(masterVolume * sfxVolume);
            }
        };

        // Apply graphics settings
        const applyGraphicsSettings = () => {
            switch (graphicsQuality) {
                case 'low':
                    renderer.shadowMap.enabled = false;
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
                    break;
                case 'medium':
                    renderer.shadowMap.enabled = shadowsEnabled;
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                    break;
                case 'high':
                    renderer.shadowMap.enabled = shadowsEnabled;
                    renderer.setPixelRatio(window.devicePixelRatio);
                    break;
            }
        };

        // Apply difficulty settings
        const getDifficultyModifier = () => {
            switch (gameDifficulty) {
                case 'easy': return 0.8;
                case 'normal': return 1.0;
                case 'hard': return 1.3;
                default: return 1.0;
            }
        };

        // Create FPS counter
        const createFPSCounter = () => {
            if (fpsCounter) return;
            fpsCounter = document.createElement('div');
            fpsCounter.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                background: rgba(0,0,0,0.8);
                color: #0f0;
                padding: 5px 10px;
                font-family: monospace;
                font-size: 12px;
                z-index: 1000;
                border-radius: 4px;
            `;
            document.body.appendChild(fpsCounter);
        };

        const updateFPS = () => {
            if (!showFPS || !fpsCounter) return;
            
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= lastTime + 1000) {
                const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                fpsCounter.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
        };

        // Update camera based on style setting
        const updateCameraStyle = (delta) => {
            if (!player) return;
            
            const camOffset = new THREE.Vector3(0, 8, 7);
            const targetPos = player.position.clone().add(camOffset);
            
            switch (cameraStyle) {
                case 'follow':
                    camera.position.copy(targetPos);
                    camera.lookAt(player.position);
                    break;
                case 'fixed':
                    // Keep camera in a fixed position
                    break;
                case 'smooth':
                    camera.position.lerp(targetPos, 0.1);
                    camera.lookAt(player.position);
                    break;
            }
        };

        // Load settings from localStorage
        const loadSettings = () => {
            const saved = localStorage.getItem('pacman3d-settings');
            if (saved) {
                const settings = JSON.parse(saved);
                masterVolume = settings.masterVolume || 0.5;
                sfxVolume = settings.sfxVolume || 0.7;
                audioMuted = settings.audioMuted || false;
                gameDifficulty = settings.gameDifficulty || 'normal';
                cameraStyle = settings.cameraStyle || 'follow';
                showFPS = settings.showFPS || false;
                graphicsQuality = settings.graphicsQuality || 'medium';
                shadowsEnabled = settings.shadowsEnabled !== false;
                particlesEnabled = settings.particlesEnabled !== false;
            }
            updateSettingsUI();
        };

        // Save settings to localStorage
        const saveSettings = () => {
            const settings = {
                masterVolume, sfxVolume, audioMuted, gameDifficulty,
                cameraStyle, showFPS, graphicsQuality, shadowsEnabled, particlesEnabled
            };
            localStorage.setItem('pacman3d-settings', JSON.stringify(settings));
            updateAudioVolume();
            applyGraphicsSettings();
            
            if (showFPS) {
                createFPSCounter();
            } else if (fpsCounter) {
                fpsCounter.remove();
                fpsCounter = null;
            }
        };

        // Update settings UI elements
        const updateSettingsUI = () => {
            document.getElementById('master-volume').value = masterVolume * 100;
            document.getElementById('master-volume-display').textContent = Math.round(masterVolume * 100) + '%';
            document.getElementById('sfx-volume').value = sfxVolume * 100;
            document.getElementById('sfx-volume-display').textContent = Math.round(sfxVolume * 100) + '%';
            document.getElementById('mute-audio').checked = audioMuted;
            document.getElementById('difficulty-select').value = gameDifficulty;
            document.getElementById('camera-select').value = cameraStyle;
            document.getElementById('show-fps').checked = showFPS;
            document.getElementById('quality-select').value = graphicsQuality;
            document.getElementById('enable-shadows').checked = shadowsEnabled;
            document.getElementById('enable-particles').checked = particlesEnabled;
        };

        // --- MAZE & OBJECTS ---
        // --- MAP DATA ---
        const levelMaps = {
            0: [ // Chapter 1 - Original map
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 5, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 5, 1],
                [1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 1, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 2, 1, 0, 1, 1, 2, 1, 1, 0, 1, 2, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 0, 2, 0, 0, 1, 9, 4, 9, 1, 0, 0, 2, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 2, 1, 0, 1, 9, 9, 9, 1, 0, 1, 2, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1],
                [1, 5, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 5, 1],
                [1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1],
                [1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            1: [ // Chapter 2 - Ice theme map layout
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 5, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 5, 1],
                [1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1],
                [1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 2, 1, 1, 1, 0, 1, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 2, 1],
                [1, 1, 1, 2, 1, 2, 1, 0, 1, 1, 2, 1, 1, 0, 1, 2, 1, 2, 1, 1, 1],
                [0, 0, 2, 2, 2, 2, 0, 0, 1, 9, 4, 9, 1, 0, 0, 2, 2, 2, 2, 0, 0],
                [1, 1, 1, 2, 1, 2, 1, 0, 1, 9, 9, 9, 1, 0, 1, 2, 1, 2, 1, 1, 1],
                [1, 2, 2, 2, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1],
                [1, 5, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 5, 1],
                [1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1],
                [1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            2: [ // Chapter 3 - Jungle Ruins theme map layout
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 5, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 5, 1],
                [1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1],
                [1, 2, 2, 1, 2, 2, 6, 1, 2, 2, 2, 2, 2, 1, 6, 2, 2, 1, 2, 2, 1], // Added monkey idols in corridors
                [1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 1, 2, 1, 0, 1, 0, 1, 2, 1, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 1, 2, 0, 0, 0, 0, 0, 2, 1, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1],
                [0, 0, 2, 2, 1, 2, 0, 0, 1, 9, 4, 9, 1, 0, 0, 2, 1, 2, 2, 0, 0],
                [1, 1, 1, 2, 1, 2, 1, 1, 1, 9, 9, 9, 1, 1, 1, 2, 1, 2, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 1, 2, 0, 0, 0, 0, 0, 2, 1, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1],
                [1, 5, 2, 1, 2, 2, 6, 1, 2, 2, 2, 2, 2, 1, 6, 2, 2, 1, 2, 5, 1], // Added monkey idols near power pellets for balance
                [1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1],
                [1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 1], // Added monkey idols in bottom corridor for strategic placement
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        };
        
        // Sticky blocks configuration for Chapter 3 - scattered throughout the maze
        const stickyBlockPositions = {
            2: [ // Chapter 3 sticky block positions (x, y coordinates)
                {x: 3, y: 3}, {x: 7, y: 5}, {x: 12, y: 4}, {x: 17, y: 6},
                {x: 5, y: 8}, {x: 15, y: 9}, {x: 2, y: 13}, {x: 18, y: 14},
                {x: 6, y: 15}, {x: 14, y: 16}, {x: 9, y: 17}, {x: 11, y: 18},
                {x: 4, y: 19}, {x: 16, y: 19}, {x: 8, y: 2}, {x: 13, y: 7},
                {x: 10, y: 12}, {x: 19, y: 10}, {x: 1, y: 11}, {x: 12, y: 15}
            ]
        };
        
        // Sticky blocks tracking
        let stickyBlocks = [];
        let playerSpeedModifier = 1.0; // Normal speed multiplier
        let isPlayerOnStickyBlock = false;
        
        const MAP_WIDTH = levelMaps[0][0].length;
        const MAP_HEIGHT = levelMaps[0].length;
        const MAP_OFFSET_X = (MAP_WIDTH / 2) * TILE_SIZE;
        const MAP_OFFSET_Z = (MAP_HEIGHT / 2) * TILE_SIZE;

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);
        scene.add(mazeObjects);

        function gridToWorld(x, z) { return new THREE.Vector3(x * TILE_SIZE - MAP_OFFSET_X + TILE_SIZE / 2, 0, z * TILE_SIZE - MAP_OFFSET_Z + TILE_SIZE / 2); }
        function worldToGrid(x, z) { return { x: Math.floor((x + MAP_OFFSET_X) / TILE_SIZE), y: Math.floor((z + MAP_OFFSET_Z) / TILE_SIZE) }; }
        function getTile(x, z) { 
            const currentLevelMap = levelMaps[currentChapterIndex];
            return currentLevelMap[z] && currentLevelMap[z][x] !== undefined ? currentLevelMap[z][x] : 1; 
        }
        
        // Check if player is perfectly centered in a tile (for sticky blocks)
        function isPlayerCentered(playerWorldPos, tileGridPos) {
            const tileWorldPos = gridToWorld(tileGridPos.x, tileGridPos.y);
            const centerThreshold = TILE_SIZE * 0.15; // 15% tolerance for "perfect center"
            
            const deltaX = Math.abs(playerWorldPos.x - tileWorldPos.x);
            const deltaZ = Math.abs(playerWorldPos.z - tileWorldPos.z);
            
            return deltaX <= centerThreshold && deltaZ <= centerThreshold;
        }
        
        // Check if a grid position is valid (within bounds and not a wall)
        function isValidPosition(gridX, gridZ) {
            // Check bounds first
            if (gridX < 0 || gridX >= MAP_WIDTH || gridZ < 0 || gridZ >= MAP_HEIGHT) {
                return false;
            }
            
            // Check if tile is not a wall (tile type 1)
            const tileType = getTile(gridX, gridZ);
            return tileType !== 1;
        }
        
        // Check if a position has a sticky block
        function isStickyBlock(gridX, gridY) {
            if (currentChapterIndex !== 2) return false; // Only Chapter 3 has sticky blocks
            
            const stickyPositions = stickyBlockPositions[currentChapterIndex] || [];
            return stickyPositions.some(pos => pos.x === gridX && pos.y === gridY);
        }
        function findTiles(tileType) { 
            const tiles = []; 
            const currentLevelMap = levelMaps[currentChapterIndex];
            for (let y = 0; y < MAP_HEIGHT; y++) 
                for (let x = 0; x < MAP_WIDTH; x++) 
                    if (currentLevelMap[y][x] === tileType) 
                        tiles.push({ x, y }); 
            return tiles; 
        }
        function canMove(obj, dir) { 
            const radius = obj.userData.radius; 
            if (!radius) return false; 
            
            const probeDist = radius + 0.2; // Increased probe distance for better collision detection
            const centerProbe = obj.position.clone().add(dir.clone().multiplyScalar(probeDist)); 
            const perpendicular = new THREE.Vector3(-dir.z, 0, dir.x).multiplyScalar(radius * 0.8); 
            const leftProbe = obj.position.clone().add(perpendicular).add(dir.clone().multiplyScalar(probeDist)); 
            const rightProbe = obj.position.clone().sub(perpendicular).add(dir.clone().multiplyScalar(probeDist)); 
            
            for (const probe of [centerProbe, leftProbe, rightProbe]) { 
                const gridPos = worldToGrid(probe.x, probe.z); 
                
                // Check bounds first
                if (gridPos.x < 0 || gridPos.x >= MAP_WIDTH || gridPos.y < 0 || gridPos.y >= MAP_HEIGHT) {
                    return false;
                }
                
                const tileType = getTile(gridPos.x, gridPos.y);
                
                // Block movement into walls
                if (tileType === 1) return false;
                
                // Allow movement over cracked floors (they are walkable until broken)
                // Walkable tiles: 0 (open), 2 (pellet), 3 (cracked floor), 4 (player spawn), 5 (power pellet), 9 (ghost spawn)
                
                // Check for temporary ice blocks (only affects ghosts, not player)
                if (obj.userData.isGhost) {
                    const hasIceBlock = temporaryIceBlocks.some(block => 
                        block.userData.gridX === gridPos.x && block.userData.gridY === gridPos.y
                    );
                    if (hasIceBlock) return false;
                }
            } 
            return true; 
        }

        function getPossibleDirections(obj) { 
            const gridPos = worldToGrid(obj.position.x, obj.position.z); 
            const allDirs = [
                { vec: new THREE.Vector3(1, 0, 0), gridX: 1, gridY: 0 }, 
                { vec: new THREE.Vector3(-1, 0, 0), gridX: -1, gridY: 0 }, 
                { vec: new THREE.Vector3(0, 0, 1), gridX: 0, gridY: 1 }, 
                { vec: new THREE.Vector3(0, 0, -1), gridX: 0, gridY: -1 }
            ]; 
            
            const oppositeDir = obj.userData.direction ? obj.userData.direction.clone().negate() : new THREE.Vector3();
            const validMoves = [];
            
            allDirs.forEach(dir => {
                // Check if this direction leads to a valid tile
                const testX = gridPos.x + dir.gridX;
                const testY = gridPos.y + dir.gridY;
                
                // Ensure within bounds
                if (testX >= 0 && testX < MAP_WIDTH && testY >= 0 && testY < MAP_HEIGHT) {
                    const tile = getTile(testX, testY);
                    if (tile !== 1) { // Not a wall
                        // Also check if the ghost can actually move in that direction
                        if (canMove(obj, dir.vec)) {
                            validMoves.push(dir);
                        }
                    }
                }
            });
            
            // Prefer non-reversing moves if multiple options
            if (validMoves.length > 1) { 
                const nonReversingMoves = validMoves.filter(dir => !dir.vec.equals(oppositeDir)); 
                if (nonReversingMoves.length > 0) return nonReversingMoves.map(p => p.vec); 
            } 
            
            return validMoves.length > 0 ? validMoves.map(p => p.vec) : []; 
        }

        // BEHAVIOR-BASED AI SYSTEM FOR DIVERSE GHOST STRATEGIES
        function calculateBehaviorTarget(ghost, currentGrid) {
            if (!player) return ghost.position;
            
            // 🐒 MONKEY DECOY OVERRIDE: If decoy is active, all ghosts target it!
            if (activeDecoy) {
                console.log(`🐒 Ghost ${ghost.uuid} targeting monkey decoy at (${activeDecoy.position.x.toFixed(2)}, ${activeDecoy.position.z.toFixed(2)}) instead of player!`);
                return activeDecoy.position.clone();
            }
            
            const playerGrid = worldToGrid(player.position.x, player.position.z);
            const playerVelocity = player.userData.velocity || new THREE.Vector3();
            
            // Update behavior timer
            ghost.userData.behaviorTimer -= 0.016; // Roughly 60fps
            
            switch (ghost.userData.behavior) {
                case 'aggressive':
                    // Direct chase - always goes straight for player
                    return player.position.clone();
                    
                case 'ambush':
                    // Tries to get ahead of player by 3-4 tiles
                    if (!ghost.userData.ambushPoint || ghost.userData.behaviorTimer <= 0) {
                        const predictedPos = player.position.clone().add(playerVelocity.clone().multiplyScalar(3));
                        const predictedGrid = worldToGrid(predictedPos.x, predictedPos.z);
                        
                        // Find a valid position near predicted location
                        for (let radius = 1; radius <= 4; radius++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                for (let dz = -radius; dz <= radius; dz++) {
                                    const testX = Math.max(0, Math.min(MAP_WIDTH - 1, predictedGrid.x + dx));
                                    const testY = Math.max(0, Math.min(MAP_HEIGHT - 1, predictedGrid.y + dz));
                                    if (getTile(testX, testY) !== 1) {
                                        ghost.userData.ambushPoint = gridToWorld(testX, testY);
                                        ghost.userData.behaviorTimer = 2.0; // Update every 2 seconds
                                        return ghost.userData.ambushPoint;
                                    }
                                }
                            }
                        }
                    }
                    return ghost.userData.ambushPoint || player.position.clone();
                    
                case 'patrol':
                    // Guards corners and key intersections
                    if (!ghost.userData.patrolTarget || ghost.userData.behaviorTimer <= 0) {
                        const keyPoints = [
                            {x: 3, y: 3}, {x: 17, y: 3}, {x: 3, y: 17}, {x: 17, y: 17},
                            {x: 10, y: 3}, {x: 10, y: 17}, {x: 3, y: 10}, {x: 17, y: 10}
                        ];
                        
                        // Find closest key point to player
                        let closestPoint = keyPoints[0];
                        let minDist = Infinity;
                        keyPoints.forEach(point => {
                            const dist = Math.abs(point.x - playerGrid.x) + Math.abs(point.y - playerGrid.y);
                            if (dist < minDist) {
                                minDist = dist;
                                closestPoint = point;
                            }
                        });
                        
                        ghost.userData.patrolTarget = gridToWorld(closestPoint.x, closestPoint.y);
                        ghost.userData.behaviorTimer = 3.0; // Update every 3 seconds
                    }
                    return ghost.userData.patrolTarget;
                    
                case 'flanker':
                    // Approaches from sides, tries to cut off escape routes
                    const playerDirection = playerVelocity.length() > 0.1 ? playerVelocity.clone().normalize() : new THREE.Vector3(1, 0, 0);
                    const perpendicular = new THREE.Vector3(-playerDirection.z, 0, playerDirection.x);
                    
                    // Choose left or right side based on ghost ID
                    const sideMultiplier = (ghost.userData.ghostId % 2 === 0) ? 1 : -1;
                    const flankPosition = player.position.clone().add(perpendicular.multiplyScalar(TILE_SIZE * 4 * sideMultiplier));
                    
                    // Ensure flanking position is valid
                    const flankGrid = worldToGrid(flankPosition.x, flankPosition.z);
                    if (flankGrid.x >= 0 && flankGrid.x < MAP_WIDTH && flankGrid.y >= 0 && flankGrid.y < MAP_HEIGHT) {
                        if (getTile(flankGrid.x, flankGrid.y) !== 1) {
                            return flankPosition;
                        }
                    }
                    // Fallback to direct chase if flanking position invalid
                    return player.position.clone();
                    
                case 'hunter':
                    // Uses enhanced prediction (for Chapter 3 mainly)
                    if (currentChapterIndex === 2) {
                        const predictedPlayerPos = player.position.clone().add(playerVelocity.clone().multiplyScalar(2));
                        return predictedPlayerPos;
                    } else {
                        // Standard tracking for other chapters
                        return player.position.clone();
                    }
                    
                case 'blocker':
                    // Tries to block player's escape routes by positioning at intersections
                    const intersections = [];
                    
                    // Find nearby intersections (tiles with 3+ open directions)
                    for (let y = 1; y < MAP_HEIGHT - 1; y++) {
                        for (let x = 1; x < MAP_WIDTH - 1; x++) {
                            if (getTile(x, y) !== 1) {
                                let openDirs = 0;
                                if (getTile(x + 1, y) !== 1) openDirs++;
                                if (getTile(x - 1, y) !== 1) openDirs++;
                                if (getTile(x, y + 1) !== 1) openDirs++;
                                if (getTile(x, y - 1) !== 1) openDirs++;
                                
                                if (openDirs >= 3) {
                                    const dist = Math.abs(x - playerGrid.x) + Math.abs(y - playerGrid.y);
                                    if (dist <= 8) { // Within reasonable range
                                        intersections.push({x, y, dist});
                                    }
                                }
                            }
                        }
                    }
                    
                    if (intersections.length > 0) {
                        // Choose intersection closest to player
                        intersections.sort((a, b) => a.dist - b.dist);
                        const target = intersections[0];
                        return gridToWorld(target.x, target.y);
                    }
                    
                    // Fallback to direct chase
                    return player.position.clone();
                    
                default:
                    return player.position.clone();
            }
        }

        function updateGhosts(delta) {
            ghosts.forEach(ghost => {
                // Handle stunned ghosts (from shield break)
                if (ghost.userData.state === 'stunned') {
                    ghost.userData.stunTimer -= delta;
                    
                    if (ghost.userData.stunTimer <= 0) {
                        // End stun and return to chasing
                        ghost.userData.state = 'chasing';
                        ghost.userData.stunTimer = 0;
                        console.log('Ghost recovered from stun');
                    } else {
                        // Make stunned ghost flash red/white
                        const flashSpeed = 5; // 5 flashes per second
                        const flashPhase = Math.floor(ghost.userData.stunTimer * flashSpeed) % 2;
                        if (ghost.material) {
                            ghost.material.color.setHex(flashPhase ? 0xff0000 : 0xffffff);
                        }
                    }
                    return; // Skip normal movement for stunned ghosts
                }
                
                // Handle entangled ghosts (from snare seed traps)
                if (ghost.userData.state === 'entangled') {
                    ghost.userData.entangleTimer -= delta;
                    
                    if (ghost.userData.entangleTimer <= 0) {
                        // End entanglement
                        ghost.userData.state = 'chasing';
                        ghost.userData.entangleTimer = 0;
                        
                        // Remove vine entanglement visual effect
                        if (ghost.userData.vineEntanglement) {
                            removeVineEntanglement(ghost.userData.vineEntanglement);
                            ghost.userData.vineEntanglement = null;
                        }
                        
                        console.log('Ghost broke free from vines');
                    } else {
                        // Make entangled ghost slightly green and immobile
                        ghost.children.forEach(child => {
                            if (child.material) {
                                child.material.emissive.setHex(0x228b22);
                                child.material.emissiveIntensity = 0.3;
                            }
                        });
                        
                        // Ghost cannot move while entangled
                        ghost.userData.velocity.set(0, 0, 0);
                    }
                    return; // Skip normal movement for entangled ghosts
                }
                
                // Handle respawning ghosts
                if (ghost.userData.state === 'respawning') {
                    ghost.userData.respawnTimer -= delta;
                    
                    if (ghost.userData.respawnTimer <= 0) {
                        // Respawn ghost
                        ghost.visible = true;
                        ghost.userData.state = 'chasing';
                        ghost.userData.respawnTimer = 0;
                        console.log('Ghost respawned and ready to chase!');
                    } else {
                        // Optional: Add blinking effect in last second
                        if (ghost.userData.respawnTimer <= 1.0) {
                            ghost.visible = Math.floor(ghost.userData.respawnTimer * 10) % 2 === 0;
                        }
                    }
                    return; // Skip normal update for respawning ghosts
                }
                
                // Skip updating invisible ghosts that are respawning
                if (!ghost.visible) {
                    return;
                }
                
                // Check for snare seed trap collisions (Chapter 3)
                if (currentChapterIndex === 2 && activeSnareSeedTraps.length > 0) {
                    const ghostGrid = worldToGrid(ghost.position.x, ghost.position.z);
                    
                    for (let i = activeSnareSeedTraps.length - 1; i >= 0; i--) {
                        const trap = activeSnareSeedTraps[i];
                        const trapGridX = trap.userData.gridX;
                        const trapGridY = trap.userData.gridY;
                        
                        // Check if ghost is on the same tile as the trap and not already entangled
                        if (ghostGrid.x === trapGridX && ghostGrid.y === trapGridY && ghost.userData.state !== 'entangled') {
                            console.log(`Ghost triggered snare seed trap at (${trapGridX}, ${trapGridY})!`);
                            
                            // Entangle the ghost
                            ghost.userData.state = 'entangled';
                            ghost.userData.entangleTimer = 3.5; // 3.5 seconds entanglement
                            
                            // Create vine entanglement visual effect at ghost's current position
                            createVineEntanglement(ghost, ghost.position.clone());
                            
                            // Mark trap as triggered but don't remove it immediately
                            if (!trap.userData.triggeredGhosts) {
                                trap.userData.triggeredGhosts = new Set();
                            }
                            trap.userData.triggeredGhosts.add(ghost.id || ghost.uuid || Math.random());
                            
                            // Schedule trap removal after a short delay to catch multiple ghosts
                            if (!trap.userData.removalScheduled) {
                                trap.userData.removalScheduled = true;
                                setTimeout(() => {
                                    const trapIndex = activeSnareSeedTraps.indexOf(trap);
                                    if (trapIndex > -1) {
                                        removeSnareSeedTrap(trap);
                                    }
                                }, 100); // 100ms delay to catch multiple ghosts
                            }
                            
                            // Award points for trapping a ghost
                            score += 200;
                            console.log(`+200 points for trapping ghost with vines! Total score: ${score}`);
                            
                            // Play sound effect
                            try {
                                sounds.powerPellet(); // Use existing sound
                            } catch (error) {
                                console.warn('Sound failed to play:', error);
                            }
                        }
                    }
                }
                
                const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];
                const speed = ghost.userData.state === "frightened" 
                    ? 0.7 * levelConfig.ghostSpeed * ghostSpeedModifier 
                    : levelConfig.ghostSpeed * ghostSpeedModifier;
                
                ghost.userData.lastDirectionChange += delta;
                
                // Get current position
                const currentGrid = worldToGrid(ghost.position.x, ghost.position.z);
                const currentWorldPos = gridToWorld(currentGrid.x, currentGrid.y);
                const distanceToGridCenter = ghost.position.distanceTo(currentWorldPos);
                
                // Force ghosts to stay within valid areas
                const minX = -MAP_OFFSET_X + TILE_SIZE * 1.5;
                const maxX = MAP_OFFSET_X - TILE_SIZE * 1.5;
                const minZ = -MAP_OFFSET_Z + TILE_SIZE * 1.5;
                const maxZ = MAP_OFFSET_Z - TILE_SIZE * 1.5;
                
                ghost.position.x = Math.max(minX, Math.min(maxX, ghost.position.x));
                ghost.position.z = Math.max(minZ, Math.min(maxZ, ghost.position.z));
                
                // Check if ghost should change direction
                const shouldChangeDirection = 
                    distanceToGridCenter < 0.3 && 
                    ghost.userData.lastDirectionChange > ghost.userData.directionChangeDelay;
                
                const isStuck = !canMove(ghost, ghost.userData.direction);
                
                if (shouldChangeDirection || isStuck) {
                    let targetPos;
                    let ghostHome = findTiles(9)[0];
                    
                    if (ghost.userData.state === "eaten") {
                        targetPos = gridToWorld(ghostHome.x, ghostHome.y);
                        if (currentGrid.x === ghostHome.x && currentGrid.y === ghostHome.y) {
                            ghost.userData.state = "exiting";
                        }
                    } else if (ghost.userData.state === "exiting") {
                        targetPos = ghost.userData.exitTarget;
                        let exitGrid = worldToGrid(targetPos.x, targetPos.z);
                        if (currentGrid.x === exitGrid.x && currentGrid.y === exitGrid.y) {
                            ghost.userData.state = "chasing";
                        }
                    } else {
                        // BEHAVIOR-BASED AI TARGETING SYSTEM
                        targetPos = calculateBehaviorTarget(ghost, currentGrid);
                    }
                    
                    const possibleDirs = getPossibleDirections(ghost);
                    
                    if (possibleDirs.length > 0) {
                        const targetGridPos = worldToGrid(targetPos.x, targetPos.z);
                        let bestDir = possibleDirs[0];
                        
                        if (ghost.userData.state === "frightened") {
                            // Run away from player - choose direction with max distance
                            let maxDistance = -1;
                            possibleDirs.forEach(dir => {
                                const testGrid = { x: currentGrid.x + dir.x, y: currentGrid.y + dir.z };
                                const distance = Math.abs(testGrid.x - targetGridPos.x) + Math.abs(testGrid.y - targetGridPos.y);
                                if (distance > maxDistance) {
                                    maxDistance = distance;
                                    bestDir = dir;
                                }
                            });
                        } else {
                            // Chase player - choose direction with min distance
                            let minDistance = Infinity;
                            
                            // Enhanced AI for Chapter 3 - Jungle Ruins
                            if (currentChapterIndex === 2) {
                                // Smarter pathfinding with prediction and better strategy
                                const playerVelocity = player.userData.velocity || new THREE.Vector3();
                                const predictedPlayerPos = player.position.clone().add(playerVelocity.clone().multiplyScalar(2));
                                const predictedGridPos = worldToGrid(predictedPlayerPos.x, predictedPlayerPos.z);
                                
                                // Use predicted position for smarter chasing
                                possibleDirs.forEach(dir => {
                                    const testGrid = { x: currentGrid.x + dir.x, y: currentGrid.y + dir.z };
                                    
                                    // Calculate distance to predicted player position
                                    const predictedDistance = Math.abs(testGrid.x - predictedGridPos.x) + Math.abs(testGrid.y - predictedGridPos.y);
                                    
                                    // Also consider direct distance as backup
                                    const directDistance = Math.abs(testGrid.x - targetGridPos.x) + Math.abs(testGrid.y - targetGridPos.y);
                                    
                                    // Weighted combination: 70% predicted, 30% direct
                                    let combinedDistance = predictedDistance * 0.7 + directDistance * 0.3;
                                    
                                    // Bonus for getting closer to player
                                    const currentDistance = Math.abs(currentGrid.x - targetGridPos.x) + Math.abs(currentGrid.y - targetGridPos.y);
                                    if (directDistance < currentDistance) {
                                        combinedDistance *= 0.8; // 20% bonus for closing in
                                    }
                                    
                                    if (combinedDistance < minDistance) {
                                        minDistance = combinedDistance;
                                        bestDir = dir;
                                    }
                                });
                            } else {
                                // Standard AI for other chapters
                                possibleDirs.forEach(dir => {
                                    const testGrid = { x: currentGrid.x + dir.x, y: currentGrid.y + dir.z };
                                    const distance = Math.abs(testGrid.x - targetGridPos.x) + Math.abs(testGrid.y - targetGridPos.y);
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        bestDir = dir;
                                    }
                                });
                            }
                        }
                        
                        ghost.userData.direction.copy(bestDir);
                        ghost.userData.lastDirectionChange = 0;
                    } else {
                        // If no valid moves, pick a random direction and hope for the best
                        const randomDirs = [
                            new THREE.Vector3(1, 0, 0),
                            new THREE.Vector3(-1, 0, 0),
                            new THREE.Vector3(0, 0, 1),
                            new THREE.Vector3(0, 0, -1)
                        ];
                        ghost.userData.direction.copy(randomDirs[Math.floor(Math.random() * randomDirs.length)]);
                    }
                }
                
                // Apply movement with collision checking
                if (canMove(ghost, ghost.userData.direction)) {
                    ghost.userData.velocity.copy(ghost.userData.direction).multiplyScalar(speed);
                } else {
                    // Try alternative directions if stuck
                    const alternativeDirs = getPossibleDirections(ghost);
                    if (alternativeDirs.length > 0) {
                        const randomDir = alternativeDirs[Math.floor(Math.random() * alternativeDirs.length)];
                        ghost.userData.direction.copy(randomDir);
                        ghost.userData.velocity.copy(randomDir).multiplyScalar(speed);
                    } else {
                        ghost.userData.velocity.set(0, 0, 0);
                    }
                }
                
                // Apply smooth movement
                const newPosition = ghost.position.clone().add(ghost.userData.velocity.clone().multiplyScalar(delta));
                
                // Final safety check - only move if the new position is valid
                const newGrid = worldToGrid(newPosition.x, newPosition.z);
                if (newGrid.x >= 0 && newGrid.x < MAP_WIDTH && 
                    newGrid.y >= 0 && newGrid.y < MAP_HEIGHT &&
                    getTile(newGrid.x, newGrid.y) !== 1) {
                    
                    ghost.position.copy(newPosition);
                }
                
                // Add floating animation
                const bobOffset = Math.sin(clock.getElapsedTime() * 5 + (ghost.id || 0)) * 0.1;
                ghost.children.forEach((child, index) => {
                    child.position.y = (index === 1 ? TILE_SIZE / 4 : 0) + bobOffset;
                });
                
                // Update materials based on state
                const isFrightened = ghost.userData.state === "frightened";
                ghost.children.forEach(child => {
                    child.material = isFrightened ? ghost.userData.frightenedMaterial : ghost.userData.baseMaterial;
                });
                
                // Hide body when eaten, shrink head
                ghost.children[0].visible = ghost.userData.state !== "eaten";
                ghost.children[1].scale.set(ghost.userData.state === "eaten" ? 0.5 : 1, 1, 1);
            });
        }
        function checkCollisions() {
            if (!player || !gameStarted) return;
            
            // Pellet collection - increased points
            for (let i = pellets.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(pellets[i].position) < TILE_SIZE / 2) {
                    const pellet = pellets[i];
                    
                    // Check if it's a monkey idol
                    if (pellet.userData && pellet.userData.type === 'monkey-idol') {
                        // 🐒 Monkey Decoy Pickup!
                        console.log('🐒 Monkey Decoy collected!');
                        hasDecoy = true;
                        sounds.powerPellet(); // Use power pellet sound for now
                        score += 200; // Special bonus for monkey idol
                        
                        // Show collection message and update UI
                        showMessage('🐒 MONKEY DECOY ACQUIRED! Press F to deploy!', 3000);
                        updateDecoyUI();
                    } else {
                        // Regular pellet
                        sounds.pellet();
                        score += 20; // Increased from 10 to 20
                    }
                    
                    mazeObjects.remove(pellets[i]);
                    pellets.splice(i, 1);
                }
            }
            
            // Power pellet collection - increased points
            for (let i = powerPellets.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(powerPellets[i].position) < TILE_SIZE / 2) {
                    sounds.powerPellet();
                    mazeObjects.remove(powerPellets[i]);
                    powerPellets.splice(i, 1);
                    score += 100; // Increased from 50 to 100
                    activatePowerup();
                }
            }
            
            // Powerup collection - NEW
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(powerups[i].position) < TILE_SIZE * 0.7) { // Increased from 0.5 to 0.7
                    activatePowerupEffect(powerups[i]);
                    mazeObjects.remove(powerups[i]);
                    powerups.splice(i, 1);
                }
            }
            
            // Bonus fruit collection - Chapter 1 (Classic)
            if (bonusFruit && player.position.distanceTo(bonusFruit.position) < TILE_SIZE * 0.7) { // Increased from 0.5 to 0.7
                sounds.powerPellet(); // Use power pellet sound for now
                score += bonusFruit.userData.points;
                console.log(`Collected ${bonusFruit.userData.fruitType} for ${bonusFruit.userData.points} points!`);
                
                // Create particle effect
                createParticleExplosion(bonusFruit.position, 0xffff00, 15);
                
                mazeObjects.remove(bonusFruit);
                bonusFruit = null;
                bonusFruitTimer = 0;
            }
            
            // Frozen fruit collection - Chapter 2 (Requires speed)
            if (frozenFruit && player.position.distanceTo(frozenFruit.position) < TILE_SIZE * 0.7) { // Increased from 0.5 to 0.7
                const currentSpeed = player.userData.velocity ? player.userData.velocity.length() : 0;
                const requiredSpeed = frozenFruit.userData.requiredSpeed;
                
                if (currentSpeed >= requiredSpeed) {
                    sounds.powerPellet(); // Use power pellet sound for now
                    score += 300; // Always give exactly 300 bonus points as requested
                    console.log(`Shattered frozen ${frozenFruit.userData.fruitType} for 300 bonus points!`);
                    
                    // Create ice shatter effect
                    createParticleExplosion(frozenFruit.position, 0x87ceeb, 20);
                    createParticleExplosion(frozenFruit.position, 0xffffff, 10);
                    
                    mazeObjects.remove(frozenFruit);
                    frozenFruit = null;
                    frozenFruitTimer = 0;
                } else {
                    console.log(`Need more speed! Current: ${currentSpeed.toFixed(2)}, Required: ${requiredSpeed.toFixed(2)}`);
                }
            }
            
            // Ghost collision with progressive scoring
            ghosts.forEach((ghost, index) => {
                // Skip collision detection for eaten/invisible ghosts
                if (!ghost.visible) {
                    return;
                }
                
                if (player.position.distanceTo(ghost.position) < TILE_SIZE / 2) {
                    if (ghost.userData.state === 'frightened') {
                        sounds.eatGhost();
                        // Award 500 points for eating frightened ghost
                        const ghostScore = 500;
                        score += ghostScore;
                        
                        // Show score popup (optional visual feedback)
                        console.log(`Ghost eaten for ${ghostScore} points! Total score: ${score}`);
                        
                        // Make ghost invisible and start respawn timer
                        ghost.visible = false;
                        ghost.userData.state = 'respawning';
                        ghost.userData.respawnTimer = 5.0; // 5 seconds respawn time
                        
                        // Move ghost to original position but keep it invisible
                        ghost.position.copy(ghost.userData.originalPosition);
                        
                    } else if (ghost.userData.state !== 'respawning') {
                        // Check if player has energy shield
                        if (isShieldActive) {
                            // Shield breaks on ghost collision
                            breakEnergyShield();
                            
                            // Stun the ghost for a moment
                            ghost.userData.state = 'stunned';
                            ghost.userData.stunTimer = 2.0; // 2 seconds stun
                            
                            // Push ghost back one tile in opposite direction
                            const dirToGhost = new THREE.Vector3()
                                .subVectors(ghost.position, player.position)
                                .normalize();
                            const pushBackDistance = TILE_SIZE;
                            ghost.position.add(dirToGhost.multiplyScalar(pushBackDistance));
                            
                            console.log('Shield broken! Ghost stunned and pushed back.');
                        } else {
                            handlePlayerDeath();
                        }
                    }
                }
            });

            const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];
            
            // Check win condition - traditional Pac-Man logic
            // Win by reaching target score OR collecting all pellets (excluding power-ups like monkey idols)
            const regularPellets = pellets.filter(pellet => 
                !pellet.userData || pellet.userData.type !== 'monkey-idol'
            );
            const pelletsRemaining = regularPellets.length + powerPellets.length;
            
            // Debug logging
            console.log(`Win condition check: Score ${score}/${levelConfig.targetScore}, Regular pellets remaining: ${pelletsRemaining}`);
            
            if (pelletsRemaining === 0 || score >= levelConfig.targetScore) {
                console.log('Level completion triggered!');
                handleLevelCompletion();
            }
        }

        function updateUI() {
            if (!gameStarted && !gameOver) return;
            const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];
            const remainingScore = Math.max(0, levelConfig.targetScore - score);
            
            scoreEl.textContent = `SCORE: ${score}/${levelConfig.targetScore} (Need: ${remainingScore} more)`;
            livesEl.textContent = `LIVES: ${lives}`;
            levelEl.textContent = `CHAPTER ${currentChapterIndex + 1} - LEVEL ${levelConfig.level}`;
            timerEl.textContent = `TIME: ${Math.ceil(levelTimer)}`;
        }

        function calculatePerformance() {
            const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];
            const timeTaken = levelConfig.timeLimit - levelTimer;
            const livesLost = livesAtLevelStart - lives;
            const levelNumber = currentLevelIndexInChapter + 1;
            
            // Make first level MUCH easier to get 3 stars
            const isFirstLevel = levelNumber === 1;
            
            // Progressive difficulty: early levels are more forgiving
            const difficultyMultiplier = Math.min(1 + (levelNumber - 1) * 0.15, 2.0); // Scales from 1.0 to 2.0
            
            // Base thresholds that get stricter with level progression
            // For first level: very generous requirements
            let timeThreshold2Star, timeThreshold3Star, scoreMultiplier2Star, scoreMultiplier3Star;
            
            if (isFirstLevel) {
                // First level: extremely forgiving
                timeThreshold2Star = 0.95; // Can use 95% of time limit
                timeThreshold3Star = 0.85; // Can use 85% of time limit
                scoreMultiplier2Star = 0.8;  // Only need 80% of target score
                scoreMultiplier3Star = 0.9;  // Only need 90% of target score
            } else {
                // Other levels: original progressive difficulty
                timeThreshold2Star = Math.max(0.6, 0.85 - (levelNumber - 1) * 0.05); // Starts at 85%, goes to 60%
                timeThreshold3Star = Math.max(0.4, 0.70 - (levelNumber - 1) * 0.06); // Starts at 70%, goes to 40%
                scoreMultiplier2Star = Math.min(1.15, 1.0 + (levelNumber - 1) * 0.03); // Starts at 100%, goes to 115%
                scoreMultiplier3Star = Math.min(1.4, 1.2 + (levelNumber - 1) * 0.04); // Starts at 120%, goes to 140%
            }
            
            let stars = 1;
            
            // 2 stars: Progressive requirements
            const timeOk2Star = timeTaken < levelConfig.timeLimit * timeThreshold2Star;
            const livesOk2Star = isFirstLevel ? livesLost <= 3 : (levelNumber <= 2 ? 2 : 1); // First level allows losing 3 lives
            const scoreOk2Star = score >= levelConfig.targetScore * scoreMultiplier2Star;
            
            if (timeOk2Star && livesOk2Star && scoreOk2Star) {
                stars = 2;
            }
            
            // 3 stars: Much easier for first level
            const timeOk3Star = timeTaken < levelConfig.timeLimit * timeThreshold3Star;
            const livesOk3Star = isFirstLevel ? livesLost <= 1 : livesLost === 0; // First level allows losing 1 life
            const scoreOk3Star = score >= levelConfig.targetScore * scoreMultiplier3Star;
            
            if (timeOk3Star && livesOk3Star && scoreOk3Star) {
                stars = 3;
            }

            // Debug logging to help understand ratings
            console.log(`Level ${levelNumber} Performance:`, {
                isFirstLevel,
                timeTaken: timeTaken.toFixed(1),
                timeLimit: levelConfig.timeLimit,
                timePercentage: (timeTaken / levelConfig.timeLimit * 100).toFixed(1) + '%',
                livesLost,
                score,
                targetScore: levelConfig.targetScore,
                scorePercentage: (score / levelConfig.targetScore * 100).toFixed(1) + '%',
                stars,
                thresholds: {
                    time2Star: (timeThreshold2Star * 100).toFixed(1) + '%',
                    time3Star: (timeThreshold3Star * 100).toFixed(1) + '%',
                    score2Star: (scoreMultiplier2Star * 100).toFixed(1) + '%',
                    score3Star: (scoreMultiplier3Star * 100).toFixed(1) + '%'
                }
            });

            return { 
                stars, 
                timeTaken: timeTaken.toFixed(1), 
                livesLost,
                levelScore: score,
                targetScore: levelConfig.targetScore
            };
        }

        function handleLevelCompletion() {
            sounds.levelUp();
            gameStarted = false;
            
            highestUnlockedLevel = Math.max(highestUnlockedLevel, currentLevelIndexInChapter + 2);
            const performance = calculatePerformance();
            
            performanceStarsEl.innerHTML = '★'.repeat(performance.stars) + '☆'.repeat(3 - performance.stars);
            levelCompleteStatsEl.innerHTML = `Time: ${performance.timeTaken}s<br>Lives Lost: ${performance.livesLost}<br>Score: ${performance.levelScore}/${performance.targetScore}`;
            
            if (currentLevelIndexInChapter >= chapters[currentChapterIndex].length - 1) {
                showChapterCompleteScreen();
                return;
            }

            if (performance.stars === 3) {
                levelCompleteTitleEl.textContent = "EXCELLENT!";
                advantageChoicesEl.style.display = 'block';
                document.getElementById('sacrifice-choices').style.display = 'none';
                disadvantageChoicesEl.style.display = 'none';
            } else if (performance.stars === 2) {
                levelCompleteTitleEl.textContent = "GREAT JOB!";
                advantageChoicesEl.style.display = 'none';
                document.getElementById('sacrifice-choices').style.display = 'block';
                disadvantageChoicesEl.style.display = 'none';
            } else {
                levelCompleteTitleEl.textContent = "LEVEL CLEAR!";
                advantageChoicesEl.style.display = 'none';
                document.getElementById('sacrifice-choices').style.display = 'none';
                disadvantageChoicesEl.style.display = 'block';
            }
            
            levelCompleteScreen.style.display = 'block';
        }

        function handlePlayerDeath() {
            if (gameOver || !gameStarted) return;
            sounds.death();
            lives--;

            if (lives <= 0) {
                endGame();
            } else {
                gameStarted = false;
                // Don't reset score on death, keep current progress
                setTimeout(() => {
                    // Restart the same level but keep the current score
                    clearLevel();
                    const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];
                    levelTimer = levelConfig.timeLimit;
                    powerUpTimer = 0;
                    
                    createMaze();
                    createGhosts(levelConfig.ghostCount, levelConfig.ghostSpeed * ghostSpeedModifier);
                    updateUI();
                    gameStarted = true;
                }, 1500);
            }
            updateUI();
        }

        function endGame() {
            gameStarted = false;
            gameOver = true;
            
            // Ensure the current level remains unlocked for retry
            // This allows players to replay levels they failed on
            highestUnlockedLevel = Math.max(highestUnlockedLevel, currentLevelIndexInChapter + 1);
            
            finalScoreEl.textContent = `You reached level ${currentLevelIndexInChapter + 1} with a score of ${score}`;
            gameOverScreen.style.display = 'block';
            uiContainer.style.opacity = 0;
        }

        function showChapterCompleteScreen() {
            gameStarted = false;
            gameOver = true;
            
            // Ensure all levels in current chapter remain accessible
            // This preserves player progression and allows chapter replay
            highestUnlockedLevel = Math.max(highestUnlockedLevel, chapters[currentChapterIndex].length);
            
            chapterCompleteScoreEl.textContent = `Your Final Score: ${score}`;
            chapterCompleteScreen.style.display = 'block';
            uiContainer.style.opacity = 0;
        }

        function createMaze() {
            const wallGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            
            // Different wall colors and materials for different chapters
            let wallMat, floorMat;
            
            if (currentChapterIndex === 1) { // Chapter 2 - Ice theme
                // Ice walls - light blue with transparency and shine
                wallMat = new THREE.MeshPhongMaterial({ 
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100,
                    specular: 0xffffff
                });
                
                // Ice floor - slightly blue with high reflection
                floorMat = new THREE.MeshPhongMaterial({ 
                    color: 0xe6f3ff,
                    shininess: 150,
                    specular: 0xcccccc,
                    transparent: true,
                    opacity: 0.9
                });
                
                isOnIce = true;
            } else if (currentChapterIndex === 2) { // Chapter 3 - Jungle Ruins theme
                // Jungle walls - brown/green stone with moss and weathering
                wallMat = new THREE.MeshLambertMaterial({ 
                    color: 0x654321, // Dark brown stone
                    roughness: 0.9,
                    map: null // Will add texture later
                });
                
                // Jungle floor - dark earthy ground
                floorMat = new THREE.MeshLambertMaterial({ 
                    color: 0x2d4b1f, // Dark jungle green
                    roughness: 0.8
                });
                
                isOnIce = false;
            } else { // Chapter 1 - Normal theme
                wallMat = new THREE.MeshStandardMaterial({ 
                    color: 0x0000ff, 
                    roughness: 0.8 
                });
                
                floorMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                isOnIce = false;
            }
            
            const floorGeo = new THREE.PlaneGeometry(MAP_WIDTH * TILE_SIZE, MAP_HEIGHT * TILE_SIZE);
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -TILE_SIZE / 2;
            floor.receiveShadow = true;
            mazeObjects.add(floor);
            
            // Get current chapter's map
            const currentLevelMap = levelMaps[currentChapterIndex];
            
            // Clear sticky blocks array
            stickyBlocks = [];
            
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tile = currentLevelMap[y][x]; 
                    const pos = gridToWorld(x, y);
                    if (tile === 1) { 
                        const wall = new THREE.Mesh(wallGeo, wallMat); 
                        wall.position.set(pos.x, 0, pos.z); 
                        wall.castShadow = true; 
                        mazeObjects.add(wall); 
                    }
                    else if (tile === 2) createPellet(pos.x, pos.z);
                    else if (tile === 3) createCrackedFloor(pos.x, pos.z, x, y); // Cracked floor
                    else if (tile === 4) createPlayer(pos.x, pos.z);
                    else if (tile === 5) createPowerPellet(pos.x, pos.z);
                    else if (tile === 6) createMonkeyIdol(pos.x, pos.z); // 🐒 Golden Monkey Idol
                    
                    // Create sticky blocks for Chapter 3
                    if (currentChapterIndex === 2 && tile === 0 && isStickyBlock(x, y)) {
                        createStickyBlock(pos.x, pos.z, x, y);
                    }
                }
            }
            
            // Add random powerups after creating the maze
            createRandomPowerups();
            
            // Enhanced lighting and effects for ice chapter
            if (currentChapterIndex === 1) {
                try {
                    // Add extra lights for ice reflection effects
                    const iceLight1 = new THREE.PointLight(0xccffff, 0.3, 30);
                    iceLight1.position.set(5, 8, 5);
                    iceLight1.userData = { isIceLight: true }; // Mark for cleanup
                    scene.add(iceLight1);
                    
                    const iceLight2 = new THREE.PointLight(0xccffff, 0.3, 30);
                    iceLight2.position.set(-5, 8, -5);
                    iceLight2.userData = { isIceLight: true }; // Mark for cleanup
                    scene.add(iceLight2);
                    
                    // Create ice particle effects
                    createIceParticles();
                } catch (error) {
                    console.log('Ice effects creation failed, continuing with basic ice theme');
                }
            }
        }

        function createPlayer(x, z) {
            const sphereGeo = new THREE.SphereGeometry(0.4 * TILE_SIZE, 32, 16, 0, Math.PI * 2, 0, Math.PI);
            sphereGeo.rotateX(-Math.PI / 2);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, side: THREE.DoubleSide });
            player = new THREE.Group();
            const topHalf = new THREE.Mesh(sphereGeo, mat);
            const bottomHalf = new THREE.Mesh(sphereGeo, mat);
            bottomHalf.rotation.x = Math.PI;
            player.add(topHalf, bottomHalf);
            player.position.set(x, 0, z);
            player.castShadow = true;
            player.userData = {
                top: topHalf,
                bottom: bottomHalf,
                velocity: new THREE.Vector3(),
                direction: new THREE.Vector3(),
                desiredDirection: new THREE.Vector3(),
                mouthAngle: 0,
                radius: 0.4 * TILE_SIZE
            };
            mazeObjects.add(player);
        }

        function createPellet(x, z) {
            const geo = new THREE.SphereGeometry(TILE_SIZE / 12, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xaaaaaa });
            const pellet = new THREE.Mesh(geo, mat);
            pellet.position.set(x, 0, z);
            pellets.push(pellet);
            mazeObjects.add(pellet);
        }

        function createPowerPellet(x, z) {
            const geo = new THREE.SphereGeometry(TILE_SIZE / 5, 16, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5 });
            const powerPellet = new THREE.Mesh(geo, mat);
            powerPellet.position.set(x, 0, z);
            powerPellets.push(powerPellet);
            mazeObjects.add(powerPellet);
        }
        
        // 🐒 Create Golden Monkey Idol (Decoy Power-Up)
        function createMonkeyIdol(x, z) {
            const group = new THREE.Group();
            
            // Create base pedestal
            const pedestalGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.3, 8);
            const pedestalMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513, // Brown
                roughness: 0.8 
            });
            const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
            pedestal.position.set(0, 0.15, 0);
            group.add(pedestal);
            
            // Create golden monkey body
            const bodyGeo = new THREE.SphereGeometry(0.15, 12, 12);
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, // Gold
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x332200 // Golden glow
            });
            const body = new THREE.Mesh(bodyGeo, goldMat);
            body.position.set(0, 0.45, 0);
            group.add(body);
            
            // Create monkey head
            const headGeo = new THREE.SphereGeometry(0.08, 10, 10);
            const head = new THREE.Mesh(headGeo, goldMat);
            head.position.set(0, 0.6, 0);
            group.add(head);
            
            // Create monkey arms
            const armGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const leftArm = new THREE.Mesh(armGeo, goldMat);
            leftArm.position.set(-0.12, 0.5, 0);
            const rightArm = new THREE.Mesh(armGeo, goldMat);
            rightArm.position.set(0.12, 0.5, 0);
            group.add(leftArm);
            group.add(rightArm);
            
            // Add golden glow particles around the idol
            const particleCount = 8;
            for (let i = 0; i < particleCount; i++) {
                const particleGeo = new THREE.SphereGeometry(0.02, 6, 6);
                const particleMat = new THREE.MeshStandardMaterial({
                    color: 0xFFFF00,
                    emissive: 0x444400,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                const angle = (i / particleCount) * Math.PI * 2;
                particle.position.set(
                    Math.cos(angle) * 0.4,
                    0.4 + Math.sin(Date.now() * 0.001 + i) * 0.1,
                    Math.sin(angle) * 0.4
                );
                group.add(particle);
            }
            
            group.position.set(x, 0, z);
            group.userData = { type: 'monkey-idol' };
            
            // Add floating animation
            group.userData.animate = function(time) {
                this.rotation.y = time * 0.002;
                this.position.y = Math.sin(time * 0.003) * 0.1;
                
                // Animate glow particles (safely check if they exist)
                const particleStartIndex = 5; // pedestal, body, head, leftArm, rightArm = 5 base objects
                const totalParticles = 8; // We created 8 particles
                
                for (let i = 0; i < totalParticles && (particleStartIndex + i) < this.children.length; i++) {
                    const childIndex = particleStartIndex + i;
                    const particle = this.children[childIndex];
                    
                    if (particle && particle.position) {
                        const angle = (i / totalParticles) * Math.PI * 2;
                        particle.position.x = Math.cos(angle + time * 0.001) * 0.4;
                        particle.position.z = Math.sin(angle + time * 0.001) * 0.4;
                        particle.position.y = 0.4 + Math.sin(time * 0.002 + i) * 0.1;
                    }
                }
            };
            
            pellets.push(group); // Add to pellets array for collision detection
            mazeObjects.add(group);
            
            console.log('🐒 Golden Monkey Idol created at', x, z);
        }

        // Create energy shield visual effect around player
        function createEnergyShield() {
            if (shieldObject) {
                scene.remove(shieldObject);
                shieldObject = null;
            }

            // Create glowing shield sphere around player
            const shieldGeo = new THREE.SphereGeometry(1.2 * TILE_SIZE, 32, 16);
            const shieldMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });

            shieldObject = new THREE.Mesh(shieldGeo, shieldMat);
            
            // Add pulsing glow effect
            shieldObject.userData = {
                pulseSpeed: 3,
                time: 0
            };

            // Position shield around player
            if (player) {
                shieldObject.position.copy(player.position);
                scene.add(shieldObject);
            }
        }

        // Remove energy shield visual effect
        function removeEnergyShield() {
            if (shieldObject) {
                scene.remove(shieldObject);
                shieldObject = null;
            }
        }

        // Create cracked floor tile that can break
        function createCrackedFloor(x, z, gridX, gridY) {
            // Create a pellet on the cracked floor (same as regular floor)
            createPellet(x, z);
            
            // Create cracked floor visual overlay
            const crackGeo = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
            const crackMat = new THREE.MeshPhongMaterial({
                color: 0x4682b4, // Darker blue for cracks
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const crackFloor = new THREE.Mesh(crackGeo, crackMat);
            crackFloor.rotation.x = -Math.PI / 2;
            crackFloor.position.set(x, -TILE_SIZE / 2 + 0.01, z); // Slightly above main floor
            
            // Add crack texture pattern
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4682b4';
            ctx.fillRect(0, 0, 64, 64);
            ctx.strokeStyle = '#1e3a5f';
            ctx.lineWidth = 2;
            
            // Draw crack lines
            ctx.beginPath();
            ctx.moveTo(10, 32);
            ctx.lineTo(54, 32);
            ctx.moveTo(32, 10);
            ctx.lineTo(32, 54);
            ctx.moveTo(15, 15);
            ctx.lineTo(49, 49);
            ctx.moveTo(49, 15);
            ctx.lineTo(15, 49);
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            crackMat.map = texture;
            crackMat.needsUpdate = true;
            
            // Store reference for breaking mechanics
            crackedFloorMeshes.set(`${gridX},${gridY}`, crackFloor);
            mazeObjects.add(crackFloor);
        }
        
        function createStickyBlock(x, z, gridX, gridY) {
            // Create sticky floor tile with distinctive muddy/swamp appearance
            const stickyGroup = new THREE.Group();
            
            // Base sticky floor - darker brownish-green
            const floorGeo = new THREE.PlaneGeometry(TILE_SIZE * 0.95, TILE_SIZE * 0.95);
            const stickyMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a5d23, // Muddy brownish-green
                transparent: true,
                opacity: 0.9
            });
            
            const stickyFloor = new THREE.Mesh(floorGeo, stickyMaterial);
            stickyFloor.rotation.x = -Math.PI / 2;
            stickyFloor.position.set(0, 0.01, 0); // Slightly above main floor
            stickyFloor.receiveShadow = true;
            stickyGroup.add(stickyFloor);
            
            // Add sticky/muddy texture with small patches
            for (let i = 0; i < 8; i++) {
                const patchGeo = new THREE.CircleGeometry(TILE_SIZE * 0.08, 6);
                const patchMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x3d4f1f, // Darker mud patches
                    transparent: true,
                    opacity: 0.7
                });
                
                const patch = new THREE.Mesh(patchGeo, patchMaterial);
                patch.rotation.x = -Math.PI / 2;
                patch.position.set(
                    (Math.random() - 0.5) * TILE_SIZE * 0.6,
                    0.02,
                    (Math.random() - 0.5) * TILE_SIZE * 0.6
                );
                stickyGroup.add(patch);
            }
            
            // Add subtle glowing border to indicate sticky nature
            const borderGeo = new THREE.RingGeometry(TILE_SIZE * 0.4, TILE_SIZE * 0.48, 16);
            const borderMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8B4513, // Brown border
                transparent: true,
                opacity: 0.6
            });
            
            const border = new THREE.Mesh(borderGeo, borderMaterial);
            border.rotation.x = -Math.PI / 2;
            border.position.set(0, 0.03, 0);
            stickyGroup.add(border);
            
            // Position the group
            stickyGroup.position.set(x, -TILE_SIZE / 2, z);
            
            // Store data
            stickyGroup.userData = {
                gridX: gridX,
                gridY: gridY,
                isStickyBlock: true,
                animationTime: Math.random() * Math.PI * 2
            };
            
            mazeObjects.add(stickyGroup);
            stickyBlocks.push(stickyGroup);
            
            console.log(`Sticky block created at (${gridX}, ${gridY})`);
        }

        // Create 3D Diamond shape with classic cut
        function createDiamondShape(size) {
            // Classic brilliant cut diamond profile matching diamond.png
            const points = [];
            
            // Crown (top section) - faceted top
            points.push(new THREE.Vector2(0, size * 0.4)); // top point
            points.push(new THREE.Vector2(size * 0.15, size * 0.25)); // upper crown
            points.push(new THREE.Vector2(size * 0.25, size * 0.1)); // lower crown
            
            // Table (flat top surface)
            points.push(new THREE.Vector2(size * 0.3, 0)); // girdle (widest part)
            
            // Pavilion (bottom section) - pointed bottom
            points.push(new THREE.Vector2(size * 0.25, -size * 0.15)); // upper pavilion
            points.push(new THREE.Vector2(size * 0.15, -size * 0.3)); // middle pavilion
            points.push(new THREE.Vector2(size * 0.05, -size * 0.45)); // lower pavilion
            points.push(new THREE.Vector2(0, -size * 0.5)); // culet (bottom point)
            
            // Create the diamond using lathe geometry for perfect symmetry
            const geometry = new THREE.LatheGeometry(points, 24); // More segments for smoother diamond
            
            return geometry;
        }

        // Create 3D Thunder/Lightning bolt shape matching thunder bolt.png
        function createThunderShape(size) {
            const shape = new THREE.Shape();
            
            // Accurate lightning bolt shape with jagged edges
            // Top section
            shape.moveTo(-size * 0.2, size * 0.5);
            shape.lineTo(size * 0.1, size * 0.5);
            shape.lineTo(size * 0.15, size * 0.3);
            shape.lineTo(size * 0.3, size * 0.35);
            shape.lineTo(size * 0.2, size * 0.1);
            
            // Middle section - main body
            shape.lineTo(size * 0.35, size * 0.15);
            shape.lineTo(size * 0.1, -size * 0.1);
            shape.lineTo(size * 0.25, -size * 0.05);
            shape.lineTo(size * 0.15, -size * 0.3);
            
            // Bottom section
            shape.lineTo(size * 0.4, -size * 0.25);
            shape.lineTo(size * 0.2, -size * 0.5);
            shape.lineTo(size * 0.05, -size * 0.45);
            shape.lineTo(-size * 0.1, -size * 0.2);
            
            // Left side back up
            shape.lineTo(-size * 0.05, -size * 0.25);
            shape.lineTo(-size * 0.15, 0);
            shape.lineTo(-size * 0.25, -size * 0.05);
            shape.lineTo(-size * 0.2, size * 0.5);
            
            const extrudeSettings = {
                depth: size * 0.12,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            return geometry;
        }

        // Create 3D Money sack shape matching money sack.png
        function createMoneySackShape(size) {
            const group = new THREE.Group();
            
            // Main sack body - bulbous shape
            const sackProfile = [];
            // Bottom point
            sackProfile.push(new THREE.Vector2(0, -size * 0.4));
            // Bottom curve
            sackProfile.push(new THREE.Vector2(size * 0.25, -size * 0.35));
            sackProfile.push(new THREE.Vector2(size * 0.35, -size * 0.2));
            // Middle bulge
            sackProfile.push(new THREE.Vector2(size * 0.4, 0));
            sackProfile.push(new THREE.Vector2(size * 0.38, size * 0.2));
            // Top narrowing
            sackProfile.push(new THREE.Vector2(size * 0.25, size * 0.35));
            sackProfile.push(new THREE.Vector2(size * 0.15, size * 0.4));
            sackProfile.push(new THREE.Vector2(0, size * 0.45));
            
            const sackGeometry = new THREE.LatheGeometry(sackProfile, 16);
            const sackMesh = new THREE.Mesh(sackGeometry);
            group.add(sackMesh);
            
            // Tied rope/string at top
            const ropeGeometry = new THREE.TorusGeometry(size * 0.18, size * 0.03, 8, 16);
            const ropeMesh = new THREE.Mesh(ropeGeometry);
            ropeMesh.position.y = size * 0.35;
            group.add(ropeMesh);
            
            // Small rope knot
            const knotGeometry = new THREE.SphereGeometry(size * 0.05, 8, 6);
            const knotMesh = new THREE.Mesh(knotGeometry);
            knotMesh.position.set(size * 0.15, size * 0.4, 0);
            group.add(knotMesh);
            
            // Return combined geometry
            const combinedGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            let indexOffset = 0;
            
            group.children.forEach(child => {
                const geometry = child.geometry;
                const positionAttribute = geometry.attributes.position;
                for (let i = 0; i < positionAttribute.count; i++) {
                    vertices.push(
                        positionAttribute.getX(i),
                        positionAttribute.getY(i),
                        positionAttribute.getZ(i)
                    );
                }
                if (geometry.index) {
                    for (let i = 0; i < geometry.index.count; i++) {
                        indices.push(geometry.index.getX(i) + indexOffset);
                    }
                }
                indexOffset += positionAttribute.count;
            });
            
            combinedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            if (indices.length > 0) {
                combinedGeometry.setIndex(indices);
            }
            combinedGeometry.computeVertexNormals();
            
            return combinedGeometry;
        }

        // Update broken floors system
        function updateBrokenFloors(delta) {
            for (let i = brokenFloors.length - 1; i >= 0; i--) {
                const brokenFloor = brokenFloors[i];
                brokenFloor.timer -= delta * 1000;
                
                if (brokenFloor.timer <= 0) {
                    // Restore the floor
                    restoreFloor(brokenFloor.x, brokenFloor.y, brokenFloor.originalTile);
                    brokenFloors.splice(i, 1);
                }
            }
        }

        // Restore a broken floor to its original state
        function restoreFloor(gridX, gridY, originalTile) {
            const key = `${gridX},${gridY}`;
            const holeMesh = holeFloorMeshes.get(key);
            
            if (holeMesh) {
                // Remove hole visual
                mazeObjects.remove(holeMesh);
                holeFloorMeshes.delete(key);
                
                // Restore map tile
                levelMaps[currentChapterIndex][gridY][gridX] = originalTile;
                
                // Recreate cracked floor visual
                const worldPos = gridToWorld(gridX, gridY);
                createCrackedFloor(worldPos.x, worldPos.z, gridX, gridY);
                
                console.log(`Floor restored at (${gridX}, ${gridY})`);
            }
        }

        // Trap a ghost that falls into a hole
        function trapGhostInHole(ghost, gridX, gridY) {
            console.log(`Ghost trapped in hole at (${gridX}, ${gridY})!`);
            
            // Make ghost invisible and start respawn timer
            ghost.visible = false;
            ghost.userData.state = 'respawning';
            ghost.userData.respawnTimer = 3.0; // 3 seconds to respawn
            
            // Award points for trapping a ghost
            score += 200;
            console.log(`+200 points for trapping ghost! Total score: ${score}`);
            
            // Optional: Add visual effect at hole location
            createTrapEffect(gridToWorld(gridX, gridY).x, gridToWorld(gridX, gridY).z);
        }

        // Create visual effect when ghost gets trapped
        function createTrapEffect(x, z) {
            // Create particle effect
            const particleCount = 10;
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x87ceeb })
                    );
                    
                    particle.position.set(
                        x + (Math.random() - 0.5) * TILE_SIZE,
                        0.5,
                        z + (Math.random() - 0.5) * TILE_SIZE
                    );
                    
                    mazeObjects.add(particle);
                    
                    // Animate particle upward
                    const animate = () => {
                        particle.position.y += 0.1;
                        particle.material.opacity -= 0.02;
                        
                        if (particle.material.opacity > 0) {
                            requestAnimationFrame(animate);
                        } else {
                            mazeObjects.remove(particle);
                        }
                    };
                    animate();
                }, i * 50);
            }
        }
        
        // Make player fall into hole
        function playerFallIntoHole(gridX, gridY) {
            console.log(`Player fell into hole at (${gridX}, ${gridY})!`);
            playerFallen = true;
            playerInHole = { x: gridX, y: gridY };
            
            // Lower player position to simulate falling
            player.position.y = -TILE_SIZE / 3;
            
            // Add falling particle effect
            createPlayerFallEffect(player.position.x, player.position.z);
            
            // Show instruction to jump
            console.log('Press J to jump out of the hole!');
        }
        
        // Jump out of hole
        function jumpOutOfHole() {
            if (!playerFallen) return;
            
            console.log('Player jumped out of hole!');
            playerFallen = false;
            playerInHole = { x: -1, y: -1 };
            
            // Restore player to normal height
            player.position.y = 0;
            
            // Add jumping particle effect
            createJumpEffect(player.position.x, player.position.z);
            
            // Award points for successful escape
            score += 50;
            console.log('+50 points for escaping the hole!');
        }
        
        // Create particle effect when player falls
        function createPlayerFallEffect(x, z) {
            const particleCount = 15;
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 6, 6),
                        new THREE.MeshBasicMaterial({ 
                            color: 0xff6b6b,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    particle.position.set(
                        x + (Math.random() - 0.5) * TILE_SIZE * 0.8,
                        0.3,
                        z + (Math.random() - 0.5) * TILE_SIZE * 0.8
                    );
                    
                    mazeObjects.add(particle);
                    
                    // Animate particle falling
                    const animate = () => {
                        particle.position.y -= 0.05;
                        particle.material.opacity -= 0.03;
                        
                        if (particle.material.opacity > 0 && particle.position.y > -1) {
                            requestAnimationFrame(animate);
                        } else {
                            mazeObjects.remove(particle);
                        }
                    };
                    animate();
                }, i * 30);
            }
        }
        
        // Create particle effect when player jumps
        function createJumpEffect(x, z) {
            const particleCount = 12;
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 6, 6),
                        new THREE.MeshBasicMaterial({ 
                            color: 0x90ee90,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                    
                    particle.position.set(
                        x + (Math.random() - 0.5) * TILE_SIZE * 0.6,
                        -0.2,
                        z + (Math.random() - 0.5) * TILE_SIZE * 0.6
                    );
                    
                    mazeObjects.add(particle);
                    
                    // Animate particle jumping up
                    const animate = () => {
                        particle.position.y += 0.08;
                        particle.material.opacity -= 0.025;
                        
                        if (particle.material.opacity > 0 && particle.position.y < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            mazeObjects.remove(particle);
                        }
                    };
                    animate();
                }, i * 40);
            }
        }



        // Create 3D Boot shape for Ice Cleats  
        function createBootShape(size) {
            // Simple light blue boot shape
            const group = new THREE.Group();
            
            // Boot sole (rectangular base)
            const soleGeometry = new THREE.BoxGeometry(size * 1.2, size * 0.15, size * 0.6);
            const soleMaterial = new THREE.MeshPhongMaterial({ color: 0x8FB8ED }); // Light blue
            const sole = new THREE.Mesh(soleGeometry, soleMaterial);
            sole.position.y = size * 0.075;
            group.add(sole);
            
            // Boot upper (ankle part)
            const upperGeometry = new THREE.BoxGeometry(size * 0.5, size * 0.8, size * 0.5);
            const upperMaterial = new THREE.MeshPhongMaterial({ color: 0x6FA4E6 }); // Slightly darker blue
            const upper = new THREE.Mesh(upperGeometry, upperMaterial);
            upper.position.y = size * 0.55;
            upper.position.x = -size * 0.2; // Slightly back on the sole
            group.add(upper);
            
            return group;
        }

        // Create 3D Snowflake shape for Flash Freeze
        function createSnowflakeShape(size) {
            const group = new THREE.Group();
            
            // Main 6-pointed snowflake structure
            const branches = 6;
            const mainRadius = size * 0.4;
            
            // Center core
            const coreGeometry = new THREE.SphereGeometry(size * 0.05, 8, 6);
            const core = new THREE.Mesh(coreGeometry);
            group.add(core);
            
            // Main branches
            for (let i = 0; i < branches; i++) {
                const angle = (i / branches) * Math.PI * 2;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                // Main branch line
                const branchGeometry = new THREE.CylinderGeometry(size * 0.02, size * 0.02, mainRadius);
                const branch = new THREE.Mesh(branchGeometry);
                branch.position.set(cos * mainRadius * 0.5, 0, sin * mainRadius * 0.5);
                branch.rotation.z = -angle + Math.PI / 2;
                group.add(branch);
                
                // Branch tip decoration
                const tipGeometry = new THREE.SphereGeometry(size * 0.03, 6, 4);
                const tip = new THREE.Mesh(tipGeometry);
                tip.position.set(cos * mainRadius, 0, sin * mainRadius);
                group.add(tip);
                
                // Sub-branches at 60% and 80% length
                for (let subPos of [0.6, 0.8]) {
                    const subX = cos * mainRadius * subPos;
                    const subZ = sin * mainRadius * subPos;
                    
                    // Left sub-branch
                    const leftAngle = angle + Math.PI / 6;
                    const leftGeometry = new THREE.CylinderGeometry(size * 0.015, size * 0.015, size * 0.15);
                    const leftBranch = new THREE.Mesh(leftGeometry);
                    leftBranch.position.set(
                        subX + Math.cos(leftAngle) * size * 0.075,
                        0,
                        subZ + Math.sin(leftAngle) * size * 0.075
                    );
                    leftBranch.rotation.z = -leftAngle + Math.PI / 2;
                    group.add(leftBranch);
                    
                    // Right sub-branch
                    const rightAngle = angle - Math.PI / 6;
                    const rightGeometry = new THREE.CylinderGeometry(size * 0.015, size * 0.015, size * 0.15);
                    const rightBranch = new THREE.Mesh(rightGeometry);
                    rightBranch.position.set(
                        subX + Math.cos(rightAngle) * size * 0.075,
                        0,
                        subZ + Math.sin(rightAngle) * size * 0.075
                    );
                    rightBranch.rotation.z = -rightAngle + Math.PI / 2;
                    group.add(rightBranch);
                }
            }
            
            return group;
        }

        // Create 3D Seed Pod shape for Snare Seed
        function createSeedPodShape(size) {
            const group = new THREE.Group();
            
            // Main seed pod body - oval shape
            const podProfile = [];
            // Create an oval profile for lathe geometry
            for (let i = 0; i <= 20; i++) {
                const angle = (i / 20) * Math.PI;
                const y = (Math.cos(angle) - 1) * size * 0.4; // Height from -0.4 to 0.4
                const x = Math.sin(angle) * size * 0.25; // Width varies
                podProfile.push(new THREE.Vector2(x, y));
            }
            
            const podGeometry = new THREE.LatheGeometry(podProfile, 16);
            const pod = new THREE.Mesh(podGeometry);
            group.add(pod);
            
            // Small stem at bottom
            const stemGeometry = new THREE.CylinderGeometry(size * 0.02, size * 0.03, size * 0.1);
            const stem = new THREE.Mesh(stemGeometry);
            stem.position.y = -size * 0.35;
            group.add(stem);
            
            // Small ridges on the pod for detail
            for (let i = 0; i < 4; i++) {
                const ridgeGeometry = new THREE.TorusGeometry(size * 0.2, size * 0.01, 4, 8);
                const ridge = new THREE.Mesh(ridgeGeometry);
                ridge.position.y = -size * 0.3 + i * size * 0.15;
                ridge.rotation.x = Math.PI / 2;
                group.add(ridge);
            }
            
            return group;
        }

        // Create 3D Ice Wall cube shape
        function createIceWallShape(size) {
            // Simple light blue cube that's easy to collect
            const geometry = new THREE.BoxGeometry(size * 0.8, size * 0.8, size * 0.8);
            return geometry;
        }

        // Create 3D Shield shape
        function createShieldShape(size) {
            const shape = new THREE.Shape();
            
            // Classic heater shield shape matching sheild.png
            // Top rounded section
            shape.moveTo(0, size * 0.5);
            shape.quadraticCurveTo(-size * 0.35, size * 0.45, -size * 0.35, size * 0.25);
            
            // Left side
            shape.lineTo(-size * 0.35, -size * 0.1);
            shape.quadraticCurveTo(-size * 0.35, -size * 0.3, -size * 0.25, -size * 0.4);
            
            // Bottom point
            shape.lineTo(0, -size * 0.6);
            
            // Right side (mirror)
            shape.lineTo(size * 0.25, -size * 0.4);
            shape.quadraticCurveTo(size * 0.35, -size * 0.3, size * 0.35, -size * 0.1);
            shape.lineTo(size * 0.35, size * 0.25);
            shape.quadraticCurveTo(size * 0.35, size * 0.45, 0, size * 0.5);
            
            const extrudeSettings = {
                depth: size * 0.15,
                bevelEnabled: true,
                bevelSegments: 4,
                steps: 3,
                bevelSize: size * 0.03,
                bevelThickness: size * 0.03
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            return geometry;
        }

        // Add this new function after createPowerPellet
        function createPowerupIcon(type, position) {
            let color, emissiveColor, geometry;
            const size = TILE_SIZE * 0.4; // Increased from 0.3 to 0.4 for better visibility
            
            // Get colors and geometry based on powerup type
            switch(type) {
                case 'shield':
                    color = '#00ff88';
                    emissiveColor = '#004422';
                    geometry = createShieldShape(size);
                    break;
                case 'speed':
                    color = '#ffff00';
                    emissiveColor = '#666600';
                    geometry = createThunderShape(size);
                    break;
                case 'points_50':
                    color = '#ffff00'; // Changed from green to yellow
                    emissiveColor = '#666600'; // Dark yellow emissive
                    geometry = createMoneySackShape(size);
                    break;
                case 'points_100':
                    color = '#0066ff'; // Changed from pink to blue
                    emissiveColor = '#002266';
                    geometry = createDiamondShape(size);
                    break;
                case 'ice_wall':
                    color = '#87ceeb';
                    emissiveColor = '#4682b4';
                    geometry = createIceWallShape(size);
                    break;
                case 'flash_freeze':
                    // Snowflake shape returns a group, not geometry
                    const snowflakeGroup = createSnowflakeShape(size);
                    
                    // Apply light blue ice material to all parts
                    snowflakeGroup.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshPhongMaterial({
                                color: '#b0e0e6',
                                emissive: '#4169e1',
                                emissiveIntensity: 0.3,
                                shininess: 120,
                                transparent: true,
                                opacity: 0.9,
                                reflectivity: 0.8
                            });
                        }
                    });
                    
                    snowflakeGroup.position.set(position.x, TILE_SIZE * 0.4, position.z); // Use Chapter 2 height
                    
                    // Add rotation animation and floating motion
                    snowflakeGroup.userData.rotationSpeed = Math.random() * 0.03 + 0.02;
                    snowflakeGroup.userData.floatOffset = Math.random() * Math.PI * 2;
                    
                    return snowflakeGroup;
                case 'ice_cleats':
                    // Boot shape returns a group, not geometry
                    const bootGroup = createBootShape(size);
                    bootGroup.position.set(position.x, TILE_SIZE * 0.4, position.z); // Use Chapter 2 height
                    
                    // Add rotation animation and floating motion
                    bootGroup.userData.rotationSpeed = Math.random() * 0.03 + 0.02;
                    bootGroup.userData.floatOffset = Math.random() * Math.PI * 2;
                    
                    return bootGroup;
                case 'snare_seed':
                    // Seed pod shape returns a group, not geometry
                    const seedGroup = createSeedPodShape(size);
                    
                    // Apply brown seed pod material to all parts
                    seedGroup.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshPhongMaterial({
                                color: '#8b4513', // Brown
                                emissive: '#654321', // Darker brown emissive
                                emissiveIntensity: 0.3,
                                shininess: 80,
                                transparent: true,
                                opacity: 0.9,
                                reflectivity: 0.6
                            });
                        }
                    });
                    
                    seedGroup.position.set(position.x, TILE_SIZE * 0.5, position.z); // Chapter 3 height
                    
                    // Add rotation animation and floating motion
                    seedGroup.userData.rotationSpeed = Math.random() * 0.03 + 0.02;
                    seedGroup.userData.floatOffset = Math.random() * Math.PI * 2;
                    
                    return seedGroup;
                default:
                    color = '#ffffff';
                    emissiveColor = '#333333';
                    geometry = createDiamondShape(size);
                    break;
            }
            
            // Create material with brilliant gem-like properties
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: emissiveColor,
                emissiveIntensity: 0.3,
                shininess: 120,
                transparent: true,
                opacity: 0.9,
                reflectivity: 0.8
            });
            
            const powerup = new THREE.Mesh(geometry, material);
            powerup.position.set(position.x, TILE_SIZE * 0.5, position.z); // Lowered from 0.7 to 0.5
            
            // Add rotation animation and floating motion
            powerup.userData.rotationSpeed = Math.random() * 0.03 + 0.02;
            powerup.userData.floatOffset = Math.random() * Math.PI * 2;
            
            return powerup;
        }
        
        function createRandomPowerups() {
            // Skip creating powerups if no-powerup mode is active
            if (noPowerupsNextLevel) {
                console.log('No powerups this level due to disadvantage!');
                noPowerupsNextLevel = false; // Reset for next level
                return;
            }
            
            const currentLevelMap = levelMaps[currentChapterIndex];
            const mapWidth = currentLevelMap[0].length;
            const mapHeight = currentLevelMap.length;
            
            // Create exactly MAX_POWERUPS at level start with good distribution
            for (let i = 0; i < MAX_POWERUPS; i++) {
                const success = spawnRandomPowerup();
                if (!success) break; // Stop if no valid positions found
            }
            
            console.log(`Level start: Created ${powerups.length} powerups with improved distribution`);
        }
        
        // Powerup management system
        const MAX_POWERUPS = 5; // Maximum powerups on map at once
        const POWERUP_LIFETIME = 30000; // 30 seconds before powerup despawns
        const POWERUP_SPAWN_INTERVAL = 5000; // Try to spawn every 5 seconds
        let lastPowerupSpawnTime = 0;

        function spawnRandomPowerup() {
            // Don't spawn if we've reached the limit
            if (powerups.length >= MAX_POWERUPS) return false;
            
            // Check spawn cooldown
            const currentTime = Date.now();
            if (currentTime - lastPowerupSpawnTime < POWERUP_SPAWN_INTERVAL) return false;
            
            // Get current level map
            const currentLevelMap = levelMaps[currentChapterIndex];
            
            // Find empty tiles in current level with improved distribution
            const emptyTiles = [];
            const mapWidth = currentLevelMap[0].length;
            const mapHeight = currentLevelMap.length;
            
            for (let y = 0; y < currentLevelMap.length; y++) {
                for (let x = 0; x < currentLevelMap[y].length; x++) {
                    if (currentLevelMap[y][x] === 0) {
                        const worldPos = gridToWorld(x, y);
                        
                        // Check if position is already occupied by another powerup
                        const occupied = powerups.some(p => 
                            Math.abs(p.position.x - worldPos.x) < TILE_SIZE * 0.5 && 
                            Math.abs(p.position.z - worldPos.z) < TILE_SIZE * 0.5
                        );
                        
                        if (!occupied) {
                            // Check minimum distance from existing powerups to prevent clustering
                            const tooClose = powerups.some(p => {
                                const distance = Math.sqrt(
                                    Math.pow(p.position.x - worldPos.x, 2) + 
                                    Math.pow(p.position.z - worldPos.z, 2)
                                );
                                return distance < TILE_SIZE * 3; // Minimum 3 tiles apart
                            });
                            
                            // Also check distance from player spawn (center) to encourage spread
                            const playerSpawn = gridToWorld(Math.floor(mapWidth/2), Math.floor(mapHeight/2));
                            const distanceFromCenter = Math.sqrt(
                                Math.pow(worldPos.x - playerSpawn.x, 2) + 
                                Math.pow(worldPos.z - playerSpawn.z, 2)
                            );
                            
                            if (!tooClose) {
                                // Add tile with preference data for better distribution
                                emptyTiles.push({ 
                                    x, 
                                    y, 
                                    worldPos,
                                    distanceFromCenter,
                                    isCorner: (x < mapWidth * 0.2 || x > mapWidth * 0.8) && 
                                             (y < mapHeight * 0.2 || y > mapHeight * 0.8),
                                    isEdge: x < mapWidth * 0.3 || x > mapWidth * 0.7 || 
                                           y < mapHeight * 0.3 || y > mapHeight * 0.7,
                                    isCenter: distanceFromCenter < TILE_SIZE * 4
                                });
                            }
                        }
                    }
                }
            }
            
            if (emptyTiles.length === 0) return false;
            
            // Improved tile selection with weighted randomization
            let selectedTile;
            const rand = Math.random();
            
            // Distribute powerups across different map areas
            if (rand < 0.3) {
                // 30% chance: Prefer corners and far edges
                const edgeTiles = emptyTiles.filter(t => t.isCorner || (t.isEdge && !t.isCenter));
                selectedTile = edgeTiles.length > 0 ? 
                    edgeTiles[Math.floor(Math.random() * edgeTiles.length)] :
                    emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            } else if (rand < 0.6) {
                // 30% chance: Prefer areas far from center
                const farTiles = emptyTiles.filter(t => t.distanceFromCenter > TILE_SIZE * 5);
                selectedTile = farTiles.length > 0 ? 
                    farTiles[Math.floor(Math.random() * farTiles.length)] :
                    emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            } else {
                // 40% chance: Completely random from all valid tiles
                selectedTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            }
            
            const pos = selectedTile.worldPos;
            
            // Different powerup logic based on chapter
            let randomType;
            if (currentChapterIndex === 1) {
                // Chapter 2: Ice Wall (40%), Flash Freeze (30%), Ice Cleats (30%)
                const rand = Math.random();
                if (rand < 0.4) {
                    randomType = 'ice_wall';
                } else if (rand < 0.7) {
                    randomType = 'flash_freeze';
                } else {
                    randomType = 'ice_cleats';
                }
            } else if (currentChapterIndex === 2) {
                // Chapter 3: Snare Seed (40%), Shield (30%), Speed (30%)
                const rand = Math.random();
                if (rand < 0.4) {
                    randomType = 'snare_seed';
                } else if (rand < 0.7) {
                    randomType = 'shield';
                } else {
                    randomType = 'speed';
                }
            } else {
                // Chapter 1: Rebalanced powerup distribution
                const speedChance = Math.random();
                if (speedChance < 0.25) {
                    // 25% chance for speed powerup (reduced from 50%)
                    randomType = 'speed';
                } else if (speedChance < 0.5) {
                    // 25% chance for shield powerup (increased from 20%)
                    randomType = 'shield';
                } else if (speedChance < 0.75) {
                    // 25% chance for 50 points (increased from 15%)
                    randomType = 'points_50';
                } else {
                    // 25% chance for 100 points (increased from 15%)
                    randomType = 'points_100';
                }
            }
            
            const powerupData = POWERUP_TYPES[randomType];
            
            // Create powerup
            const powerup = createPowerupIcon(randomType, pos);
            
            // Store powerup data
            powerup.userData.type = randomType;
            powerup.userData.points = powerupData.points;
            powerup.userData.effect = powerupData.effect;
            powerup.userData.duration = powerupData.duration;
            powerup.userData.spawnTime = Date.now(); // Track when powerup was spawned
            powerup.userData.lifetime = POWERUP_LIFETIME; // How long it should exist
            
            powerups.push(powerup);
            mazeObjects.add(powerup);
            
            lastPowerupSpawnTime = Date.now(); // Update spawn timer
            console.log(`Spawned ${randomType} powerup at position (${selectedTile.x}, ${selectedTile.y}). Total: ${powerups.length}/${MAX_POWERUPS}`);
            return true; // Success
        }

        // Update powerup lifetimes and remove expired ones
        function updatePowerupLifetimes() {
            const currentTime = Date.now();
            const toRemove = [];
            
            powerups.forEach((powerup, index) => {
                if (powerup.userData.spawnTime) {
                    const age = currentTime - powerup.userData.spawnTime;
                    const remainingLife = powerup.userData.lifetime - age;
                    
                    // Warning effect when powerup is about to expire (last 5 seconds)
                    if (remainingLife <= 5000 && remainingLife > 0) {
                        const blinkSpeed = Math.sin(currentTime * 0.01); // Fast blinking
                        const opacity = 0.5 + 0.5 * Math.abs(blinkSpeed);
                        
                        // Handle both mesh and group powerups
                        if (powerup.material) {
                            // Single mesh powerup
                            powerup.material.opacity = opacity;
                            powerup.material.transparent = true;
                        } else if (powerup.traverse) {
                            // Group powerup - apply to all child meshes
                            powerup.traverse((child) => {
                                if (child.material) {
                                    child.material.opacity = opacity;
                                    child.material.transparent = true;
                                }
                            });
                        }
                    }
                    
                    // Remove expired powerups
                    if (remainingLife <= 0) {
                        toRemove.push(index);
                        console.log(`Powerup ${powerup.userData.type} expired and despawned`);
                    }
                }
            });
            
            // Remove expired powerups (in reverse order to maintain indices)
            toRemove.reverse().forEach(index => {
                const powerup = powerups[index];
                mazeObjects.remove(powerup);
                powerups.splice(index, 1);
            });
        }

        function activatePowerupEffect(powerup) {
            const { effect, points, duration } = powerup.userData;
            
            switch (effect) {
                case 'shield':
                    playerShield = true;
                    shieldTimer = duration;
                    addActivePowerup('shield', duration); // Add to active powerups display
                    sounds.powerPellet(); // Use existing sound
                    console.log('Shield activated!');
                    break;
                    
                case 'speed':
                    playerSpeed *= 1.5; // 50% speed boost
                    const speedPowerupId = addActivePowerup('speed', duration); // Add to active powerups display
                    setTimeout(() => {
                        playerSpeed = BASE_PLAYER_SPEED; // Reset to base speed
                        removeActivePowerup(speedPowerupId); // Remove from display when expired
                    }, duration * 1000);
                    sounds.powerPellet();
                    console.log('Speed boost activated!');
                    break;
                    
                case 'points':
                    score += points;
                    sounds.pellet();
                    console.log(`+${points} points!`);
                    
                    // Show brief visual feedback for points powerups
                    const pointsType = points === 50 ? 'points_50' : 'points_100';
                    const pointsPowerupId = addActivePowerup(pointsType, 2000); // Show for 2 seconds
                    setTimeout(() => {
                        removeActivePowerup(pointsPowerupId);
                    }, 2000);
                    break;
                    
                case 'ice_wall':
                    iceWallCharges += 1;
                    score += points;
                    sounds.powerPellet(); // Use existing sound
                    console.log(`Ice Wall charge gained! Total charges: ${iceWallCharges}`);
                    updateIceWallUI();
                    // Ice wall charges are permanent, no duration display needed
                    break;
                    
                case 'flash_freeze':
                    flashFreezeActive = true;
                    flashFreezeTimer = duration;
                    addActivePowerup('flash_freeze', duration); // Add to active powerups display
                    score += points;
                    createFrostAura();
                    sounds.powerPellet();
                    console.log('Flash Freeze activated! Ghosts slowed for ' + duration/1000 + ' seconds');
                    break;
                    
                case 'ice_cleats':
                    iceCleatsActive = true;
                    iceCleatsTimer = duration;
                    addActivePowerup('ice_cleats', duration); // Add to active powerups display
                    score += points;
                    createTractionAura();
                    sounds.powerPellet();
                    console.log('Ice Cleats activated! Perfect traction for ' + duration/1000 + ' seconds');
                    break;
                    
                case 'snare_seed':
                    snareSeedCharges += 1;
                    score += points;
                    sounds.powerPellet(); // Use existing sound
                    console.log(`Snare Seed charge gained! Total charges: ${snareSeedCharges}`);
                    updateSnareSeedUI();
                    // Snare seed charges are permanent, no duration display needed
                    break;
            }
        }

        // Apply selected starting powerup
        function applyStartingPowerup() {
            if (!selectedPowerupType) return;
            
            const powerupData = POWERUP_TYPES[selectedPowerupType];
            const mockPowerup = { userData: powerupData };
            
            activatePowerupEffect(mockPowerup);
            console.log(`Starting with ${selectedPowerupType} powerup!`);
            
            // Reset selection
            selectedPowerupType = null;
        }
        
        // Create particle explosion effect for fruit collection
        function createParticleExplosion(position, color, particleCount) {
            try {
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = [];
                
                // Create particles with random positions and velocities
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Start all particles at the explosion position
                    positions[i3] = position.x;
                    positions[i3 + 1] = position.y;
                    positions[i3 + 2] = position.z;
                    
                    // Random velocity for each particle
                    velocities.push({
                        x: (Math.random() - 0.5) * 10,
                        y: Math.random() * 8 + 2,
                        z: (Math.random() - 0.5) * 10
                    });
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: color,
                    size: 0.5,
                    transparent: true,
                    opacity: 1.0
                });
                
                const particleSystem = new THREE.Points(particles, particleMaterial);
                scene.add(particleSystem);
                
                // Animate particles
                let life = 1.0;
                const animate = () => {
                    life -= 0.02;
                    
                    if (life <= 0) {
                        scene.remove(particleSystem);
                        return;
                    }
                    
                    // Update particle positions
                    const positions = particleSystem.geometry.attributes.position.array;
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        positions[i3] += velocities[i].x * 0.02;
                        positions[i3 + 1] += velocities[i].y * 0.02;
                        positions[i3 + 2] += velocities[i].z * 0.02;
                        
                        // Apply gravity to Y velocity
                        velocities[i].y -= 0.3;
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                    particleMaterial.opacity = life;
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            } catch (error) {
                console.warn('Failed to create particle explosion:', error);
            }
        }

        function createIceParticles() {
            try {
                const particleCount = 100; // Reduced count for better performance
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * MAP_WIDTH * TILE_SIZE;
                    positions[i + 1] = Math.random() * 15 + 2;
                    positions[i + 2] = (Math.random() - 0.5) * MAP_HEIGHT * TILE_SIZE;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0xccffff,
                    size: 0.3,
                    transparent: true,
                    opacity: 0.4
                });
                
                const particleSystem = new THREE.Points(particles, particleMaterial);
                particleSystem.userData = { isIceParticle: true }; // Mark for cleanup
                scene.add(particleSystem);
            } catch (error) {
                console.log('Ice particles creation failed, continuing without particles');
            }
        }
        
        function resetIcePhysics() {
            iceSlipDistance = 0;
            iceSlipDirection.set(0, 0, 0);
            iceTurnDelay = 0;
        }

        function createGhosts(count, speed) {
            const colors = [0xff0000, 0xff80ff, 0x00ffff, 0xffb851, 0x00ff00, 0x800080];
            const spawnPositions = [
                { x: 1, y: 1, state: "chasing" },
                { x: 19, y: 1, state: "chasing" },
                { x: 1, y: 19, state: "chasing" },
                { x: 19, y: 19, state: "chasing" },
                { x: 10, y: 1, state: "chasing" },
                { x: 10, y: 10, state: "exiting" }
            ];

            // Define different AI behaviors for ghost diversity
            const ghostBehaviors = [
                'aggressive',   // Direct chase - fastest route to player
                'ambush',      // Tries to get ahead of player
                'patrol',      // Guards key areas and corners
                'flanker',     // Approaches from sides
                'hunter',      // Predicts player movement
                'blocker'      // Tries to block escape routes
            ];

            for (let i = 0; i < count; i++) {
                const spawn = spawnPositions[i % spawnPositions.length];
                const pos = gridToWorld(spawn.x, spawn.y);
                const bodyGeo = new THREE.CylinderGeometry(TILE_SIZE / 3, TILE_SIZE / 3, TILE_SIZE / 2, 16);
                const headGeo = new THREE.SphereGeometry(TILE_SIZE / 3, 16, 16);
                const mat = new THREE.MeshStandardMaterial({ color: colors[i % colors.length] });
                const ghost = new THREE.Group();
                const body = new THREE.Mesh(bodyGeo, mat);
                const head = new THREE.Mesh(headGeo, mat);
                head.position.y = TILE_SIZE / 4;
                ghost.add(body, head);
                ghost.position.set(pos.x, 0, pos.z);
                ghost.castShadow = true;

                const exitTarget = { x: 10, y: 8 };
                ghost.userData = {
                    isGhost: true, // Mark as ghost for ice block collision detection
                    radius: TILE_SIZE / 3,
                    baseMaterial: mat,
                    frightenedMaterial: new THREE.MeshStandardMaterial({ color: 0x2222ff, emissive: 0x888fff }),
                    direction: new THREE.Vector3(0, 0, -1),
                    velocity: new THREE.Vector3(0, 0, 0),
                    speed: speed,
                    state: spawn.state,
                    exitTarget: gridToWorld(exitTarget.x, exitTarget.y),
                    lastDirectionChange: 0,
                    directionChangeDelay: 0.3,
                    respawnTimer: 0, // Timer for respawning after being eaten
                    originalPosition: new THREE.Vector3(pos.x, 0, pos.z), // Store original position
                    
                    // AI Behavior System
                    behavior: ghostBehaviors[i % ghostBehaviors.length],
                    ghostId: i,
                    patrolTarget: null,
                    ambushPoint: null,
                    behaviorTimer: Math.random() * 3.0 // Randomize behavior changes
                };
                ghosts.push(ghost);
                mazeObjects.add(ghost);
            }
        }

        // Adrenaline Dash System Functions
        function activateDash() {
            console.log('Activating Adrenaline Dash!');
            
            // Set dash state
            dashActive = true;
            dashTimer = DASH_EFFECT_DURATION;
            dashCooldown = DASH_COOLDOWN_DURATION;
            
            // Play dash sound
            try {
                sounds.dash();
            } catch (error) {
                console.warn('Dash sound failed to play:', error);
            }
            
            // Visual FOV effect
            const targetFOV = originalFOV * 1.3; // Increase FOV for tunnel vision effect
            animateCameraFOV(camera.fov, targetFOV, 0.3); // 0.3 second FOV transition
            
            // Create particle trail
            createDashParticleTrail();
            
            // Update UI
            updateDashDisplay();
            
            console.log(`Dash activated! Speed boost for ${DASH_EFFECT_DURATION}s, cooldown ${DASH_COOLDOWN_DURATION}s`);
        }
        
        // Energy Shield System Functions
        function activateEnergyShield() {
            console.log('Activating Energy Shield!');
            
            // Set shield state
            isShieldActive = true;
            shieldDuration = SHIELD_DURATION_TIME;
            shieldCooldown = SHIELD_COOLDOWN_TIME;
            
            // Create visual shield effect
            createEnergyShield();
            
            // Play shield activation sound
            try {
                sounds.shieldActivate();
            } catch (error) {
                console.warn('Shield activation sound failed to play:', error);
            }
            
            // Update UI
            updateShieldDisplay();
            
            console.log(`Shield activated! Protection for ${SHIELD_DURATION_TIME}s, cooldown ${SHIELD_COOLDOWN_TIME}s`);
        }

        function deactivateEnergyShield() {
            console.log('Energy Shield deactivated');
            
            isShieldActive = false;
            shieldDuration = 0;
            
            // Remove visual shield effect
            removeEnergyShield();
            
            // Play shield deactivation sound
            try {
                sounds.shieldDeactivate();
            } catch (error) {
                console.warn('Shield deactivation sound failed to play:', error);
            }
            
            // Update UI
            updateShieldDisplay();
        }

        function breakEnergyShield() {
            console.log('Energy Shield broken by ghost collision!');
            
            isShieldActive = false;
            shieldDuration = 0;
            
            // Remove visual shield effect
            removeEnergyShield();
            
            // Play shield break sound (different from deactivation)
            try {
                sounds.shieldBreak();
            } catch (error) {
                console.warn('Shield break sound failed to play:', error);
            }
            
            // Update UI
            updateShieldDisplay();
        }
        
        function updateDashSystem(delta) {
            // Update dash effect timer
            if (dashActive) {
                dashTimer -= delta;
                
                if (dashTimer <= 0) {
                    // End dash effect
                    dashActive = false;
                    dashTimer = 0;
                    
                    // Return FOV to normal
                    animateCameraFOV(camera.fov, originalFOV, 0.5); // 0.5 second return transition
                    
                    console.log('Dash effect ended');
                }
            }
            
            // Update cooldown timer
            if (dashCooldown > 0) {
                dashCooldown -= delta;
                if (dashCooldown < 0) dashCooldown = 0;
            }
            
            // Update dash particles
            updateDashParticles(delta);
            
            // Update UI display
            updateDashDisplay();
        }
        
        function updateDashDisplay() {
            const dashStatusEl = document.getElementById('dash-status');
            if (!dashStatusEl) return;
            
            if (dashActive) {
                dashStatusEl.textContent = 'DASH ACTIVE!';
                dashStatusEl.className = 'active';
            } else if (dashCooldown > 0) {
                dashStatusEl.textContent = `RECHARGING ${Math.ceil(dashCooldown)}s`;
                dashStatusEl.className = 'recharging';
            } else {
                dashStatusEl.textContent = 'DASH READY';
                dashStatusEl.className = 'ready';
            }
        }
        
        function updateShieldDisplay() {
            const shieldStatusEl = document.getElementById('shield-status');
            if (!shieldStatusEl) return;
            
            if (isShieldActive) {
                shieldStatusEl.textContent = '🛡️ SHIELD ACTIVE!';
                shieldStatusEl.className = 'active';
            } else if (shieldCooldown > 0) {
                shieldStatusEl.textContent = `🛡️ RECHARGING ${Math.ceil(shieldCooldown)}s`;
                shieldStatusEl.className = 'recharging';
            } else {
                shieldStatusEl.textContent = '🛡️ SHIELD READY';
                shieldStatusEl.className = 'ready';
            }
        }
        
        function updateShieldSystem(delta) {
            // Update shield duration timer
            if (isShieldActive) {
                shieldDuration -= delta;
                
                if (shieldDuration <= 0) {
                    // End shield effect naturally
                    deactivateEnergyShield();
                    console.log('Shield effect ended naturally');
                }
                
                // Update shield visual position to follow player
                if (shieldObject && player) {
                    shieldObject.position.copy(player.position);
                    
                    // Animate shield pulsing effect
                    shieldObject.userData.time += delta;
                    const pulseScale = 1 + Math.sin(shieldObject.userData.time * shieldObject.userData.pulseSpeed) * 0.1;
                    shieldObject.scale.setScalar(pulseScale);
                    
                    // Update shield opacity based on remaining duration
                    const opacityFactor = Math.max(0.3, shieldDuration / SHIELD_DURATION_TIME);
                    shieldObject.material.opacity = 0.3 * opacityFactor;
                }
            }
            
            // Update cooldown timer
            if (shieldCooldown > 0) {
                shieldCooldown -= delta;
                if (shieldCooldown < 0) shieldCooldown = 0;
            }
            
            // Update UI display
            updateShieldDisplay();
        }
        
        function animateCameraFOV(fromFOV, toFOV, duration) {
            const startTime = performance.now();
            
            function updateFOV() {
                const elapsed = (performance.now() - startTime) / 1000;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.fov = fromFOV + (toFOV - fromFOV) * easedProgress;
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(updateFOV);
                }
            }
            
            updateFOV();
        }
        
        function createDashParticleTrail() {
            // Create bright yellow particles behind the player
            for (let i = 0; i < 15; i++) {
                const particle = {
                    position: player.position.clone(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2 + 1,
                        (Math.random() - 0.5) * 2
                    ),
                    life: 1.0,
                    maxLife: 1.0,
                    size: Math.random() * 0.3 + 0.2
                };
                
                // Create particle mesh
                const geometry = new THREE.SphereGeometry(particle.size, 8, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(particle.position);
                scene.add(mesh);
                
                particle.mesh = mesh;
                dashParticles.push(particle);
            }
        }
        
        function updateDashParticles(delta) {
            for (let i = dashParticles.length - 1; i >= 0; i--) {
                const particle = dashParticles[i];
                
                // Update particle
                particle.life -= delta * 2; // Particles last 0.5 seconds
                particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                particle.velocity.y -= 9.8 * delta; // Gravity
                
                // Update mesh
                if (particle.mesh) {
                    particle.mesh.position.copy(particle.position);
                    particle.mesh.material.opacity = Math.max(0, particle.life / particle.maxLife);
                }
                
                // Remove dead particles
                if (particle.life <= 0) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                    dashParticles.splice(i, 1);
                }
            }
        }

        function updatePlayer(delta) {
            if (!player) return;
            const { velocity, direction, desiredDirection, top, bottom } = player.userData;
            
            // Check sticky block interaction (Chapter 3 only)
            if (currentChapterIndex === 2) {
                updateStickyBlockInteraction();
            }
            
            let actualSpeed = playerSpeed;
            
            // Apply Adrenaline Dash speed boost
            if (dashActive) {
                actualSpeed *= DASH_SPEED_MULTIPLIER;
            }
            
            // Ice physics for Chapter 2 (bypassed when Ice Cleats are active)
            if (isOnIce && currentChapterIndex === 1 && !iceCleatsActive) {
                // Build up momentum while moving
                if (velocity.length() > 0 && iceSlipDistance < 2.0) {
                    iceSlipDistance += ICE_MOMENTUM_BUILDUP; // Gradually build momentum
                    iceSlipDirection.copy(direction).normalize();
                }
                
                // Handle ice slip momentum
                if (iceSlipDistance > ICE_SLIP_THRESHOLD) {
                    const slipMovement = iceSlipDirection.clone().multiplyScalar(iceSlipDistance * 0.025); // Slightly increased
                    const testPosition = player.position.clone().add(slipMovement.multiplyScalar(delta));
                    const testGridPos = worldToGrid(testPosition.x, testPosition.z);
                    
                    // Only apply slip if it won't cause wall collision
                    if (getTile(testGridPos.x, testGridPos.y) !== 1) {
                        player.position.add(slipMovement.multiplyScalar(delta));
                    } else {
                        // Reduce slip when hitting wall but don't stop completely
                        iceSlipDistance *= 0.5; // Less reduction for more bounce
                        iceSlipDirection.multiplyScalar(-0.3); // Small bounce back
                    }
                    
                    iceSlipDistance *= ICE_SLIP_FACTOR; // Gradually slow down (now retains more momentum)
                    
                    // Reduce turn responsiveness while slipping
                    if (iceTurnDelay > 0) {
                        iceTurnDelay--;
                    }
                }
                
                // Make movement feel slippery but maintain good speed
                actualSpeed *= 1.5; // Keep the same speed multiplier
            }

            // Handle direction changes with ice physics
            if (!desiredDirection.equals(new THREE.Vector3(0, 0, 0))) {
                let canChangeDirection = true;
                
                // On ice, make turning harder and add delay (bypassed by Ice Cleats)
                if (isOnIce && currentChapterIndex === 1 && !iceCleatsActive) {
                    // Reduce turn delay when against wall to prevent getting stuck
                    if (iceTurnDelay > 0 && !canMove(player, direction)) {
                        iceTurnDelay = Math.max(0, iceTurnDelay - 2); // Faster recovery when stuck
                    }
                    
                    if (iceTurnDelay > 0) {
                        canChangeDirection = false; // Must wait for turn delay
                    }
                    
                    // More lenient positioning for turns when against walls
                    const gridPos = worldToGrid(player.position.x, player.position.z);
                    const centerPos = gridToWorld(gridPos.x, gridPos.y);
                    const distToCenter = player.position.distanceTo(centerPos);
                    const threshold = !canMove(player, direction) ? 0.3 : 0.15; // Larger threshold when stuck
                    if (distToCenter > threshold) {
                        canChangeDirection = false;
                    }
                }
                
                if (canChangeDirection && canMove(player, desiredDirection)) {
                    direction.copy(desiredDirection);
                    velocity.copy(direction).multiplyScalar(actualSpeed);
                    player.lookAt(player.position.clone().add(direction));
                    
                    // Add slip momentum on ice when changing direction (enhanced)
                    if (isOnIce && currentChapterIndex === 1) {
                        iceSlipDirection = direction.clone();
                        iceSlipDistance = ICE_INITIAL_SLIP; // Increased initial slip momentum
                        iceTurnDelay = ICE_TURN_DELAY; // Add turn delay after changing direction
                    }
                } else if (!canChangeDirection && isOnIce && currentChapterIndex === 1) {
                    // On ice, maintain good speed even when turn is delayed
                    velocity.copy(direction).multiplyScalar(actualSpeed * 0.8); // Increased from 0.5 to 0.8
                }
            } else if (!isOnIce || currentChapterIndex !== 1) {
                // Normal movement for non-ice chapters
                velocity.copy(direction).multiplyScalar(actualSpeed);
            }

            // Wall collision handling
            if (!canMove(player, direction)) {
                velocity.set(0, 0, 0);
                
                // On ice, handle wall bouncing with enhanced physics (bypassed by Ice Cleats)
                if (isOnIce && currentChapterIndex === 1 && !iceCleatsActive) {
                    // More realistic ice wall collision - reduce but don't eliminate slip
                    if (iceSlipDistance > 1.0) {
                        iceSlipDistance *= 0.6; // Less reduction for more realistic ice physics
                        // Try to slip along the wall in perpendicular direction
                        const perpDir = new THREE.Vector3(-iceSlipDirection.z, 0, iceSlipDirection.x);
                        if (Math.random() > 0.5) perpDir.multiplyScalar(-1); // Random side
                        iceSlipDirection.copy(perpDir).normalize();
                    } else {
                        iceSlipDistance *= 0.3;
                        iceSlipDirection.set(0, 0, 0);
                    }
                    
                    // Reduce turn delay when stuck against wall but keep some
                    if (iceTurnDelay > 2) {
                        iceTurnDelay = 2; // Faster recovery but still some delay
                    }
                }
            }

            player.position.add(velocity.clone().multiplyScalar(delta));
            
            player.userData.mouthAngle += 15 * delta * (velocity.length() > 0 ? 1 : -1);
            player.userData.mouthAngle = Math.max(0, Math.min(Math.PI / 4, player.userData.mouthAngle));
            top.rotation.z = player.userData.mouthAngle;
            bottom.rotation.z = -player.userData.mouthAngle;
        }

        function activatePowerup() { 
            powerUpTimer = chapters[currentChapterIndex][currentLevelIndexInChapter].powerUpDuration; 
            ghosts.forEach(g => { 
                if (g.userData.state === 'chasing') g.userData.state = 'frightened' 
            }); 
        }

        function proceedToNextLevel() {
            levelCompleteScreen.style.display = 'none';
            document.getElementById('powerup-selection-screen').style.display = 'none';
            
            if (currentLevelIndexInChapter < chapters[currentChapterIndex].length - 1) {
                currentLevelIndexInChapter++;
                startLevel(currentLevelIndexInChapter);
                uiContainer.style.opacity = 1;
                gameStarted = true;
            } else {
                showChapterCompleteScreen();
            }
        }

        // --- GAME LOOP ---
        // BONUS FRUIT SYSTEM
        function createFruitGeometry(fruitType) {
            switch(fruitType) {
                case 'cherry':
                    const cherryGroup = new THREE.Group();
                    // Main cherry body - slightly larger
                    const cherryGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.25, 16, 12);
                    const cherry = new THREE.Mesh(cherryGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        shininess: 60,
                        specular: 0x442222
                    }));
                    // Small cherry stem
                    const stemGeometry = new THREE.CylinderGeometry(TILE_SIZE * 0.02, TILE_SIZE * 0.02, TILE_SIZE * 0.15);
                    const stem = new THREE.Mesh(stemGeometry, new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
                    stem.position.y = TILE_SIZE * 0.2;
                    cherryGroup.add(cherry);
                    cherryGroup.add(stem);
                    return cherryGroup;
                case 'strawberry':
                    const strawberryGroup = new THREE.Group();
                    // Main strawberry body - cone-like shape
                    const strawberryGeometry = new THREE.ConeGeometry(TILE_SIZE * 0.2, TILE_SIZE * 0.4, 12);
                    const strawberry = new THREE.Mesh(strawberryGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0xff6b6b,
                        shininess: 40,
                        specular: 0x662222
                    }));
                    strawberry.position.y = TILE_SIZE * 0.1;
                    // Small green top
                    const topGeometry = new THREE.ConeGeometry(TILE_SIZE * 0.12, TILE_SIZE * 0.08, 8);
                    const top = new THREE.Mesh(topGeometry, new THREE.MeshPhongMaterial({ color: 0x228B22 }));
                    top.position.y = TILE_SIZE * 0.35;
                    strawberryGroup.add(strawberry);
                    strawberryGroup.add(top);
                    return strawberryGroup;
                case 'apple':
                    const appleGroup = new THREE.Group();
                    // Main apple body - slightly flattened sphere
                    const appleGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.28, 16, 12);
                    appleGeometry.scale(1, 0.9, 1);
                    const apple = new THREE.Mesh(appleGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        shininess: 80,
                        specular: 0x224422
                    }));
                    // Small apple stem
                    const appleStemGeometry = new THREE.CylinderGeometry(TILE_SIZE * 0.015, TILE_SIZE * 0.015, TILE_SIZE * 0.1);
                    const appleStem = new THREE.Mesh(appleStemGeometry, new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
                    appleStem.position.y = TILE_SIZE * 0.2;
                    appleGroup.add(apple);
                    appleGroup.add(appleStem);
                    return appleGroup;
                default:
                    return new THREE.Mesh(
                        new THREE.SphereGeometry(TILE_SIZE * 0.25, 16, 12),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xffaa00,
                            shininess: 60,
                            specular: 0x664422
                        })
                    );
            }
        }
        
        function createFrozenFruitGeometry(fruitType) {
            // Create same fruit shapes as Chapter 1 but with light blue colors
            switch(fruitType) {
                case 'cherry':
                    const cherryGroup = new THREE.Group();
                    // Main cherry body - slightly larger
                    const cherryGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.25, 16, 12);
                    const cherry = new THREE.Mesh(cherryGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x87ceeb, // Light blue
                        shininess: 60,
                        specular: 0x4482b4,
                        emissive: 0x223366,
                        emissiveIntensity: 0.1
                    }));
                    // Small cherry stem
                    const stemGeometry = new THREE.CylinderGeometry(TILE_SIZE * 0.02, TILE_SIZE * 0.02, TILE_SIZE * 0.15);
                    const stem = new THREE.Mesh(stemGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x6495ed,
                        emissive: 0x112244,
                        emissiveIntensity: 0.1
                    }));
                    stem.position.y = TILE_SIZE * 0.2;
                    cherryGroup.add(cherry);
                    cherryGroup.add(stem);
                    return cherryGroup;
                case 'strawberry':
                    const strawberryGroup = new THREE.Group();
                    // Main strawberry body - cone-like shape
                    const strawberryGeometry = new THREE.ConeGeometry(TILE_SIZE * 0.2, TILE_SIZE * 0.4, 12);
                    const strawberry = new THREE.Mesh(strawberryGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x87ceeb, // Light blue
                        shininess: 40,
                        specular: 0x4482b4,
                        emissive: 0x223366,
                        emissiveIntensity: 0.1
                    }));
                    strawberry.position.y = TILE_SIZE * 0.1;
                    // Small green top - also light blue
                    const topGeometry = new THREE.ConeGeometry(TILE_SIZE * 0.12, TILE_SIZE * 0.08, 8);
                    const top = new THREE.Mesh(topGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x6495ed,
                        emissive: 0x112244,
                        emissiveIntensity: 0.1
                    }));
                    top.position.y = TILE_SIZE * 0.35;
                    strawberryGroup.add(strawberry);
                    strawberryGroup.add(top);
                    return strawberryGroup;
                case 'apple':
                    const appleGroup = new THREE.Group();
                    // Main apple body - slightly flattened sphere
                    const appleGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.28, 16, 12);
                    appleGeometry.scale(1, 0.9, 1);
                    const apple = new THREE.Mesh(appleGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x87ceeb, // Light blue
                        shininess: 80,
                        specular: 0x4482b4,
                        emissive: 0x223366,
                        emissiveIntensity: 0.1
                    }));
                    // Small apple stem
                    const appleStemGeometry = new THREE.CylinderGeometry(TILE_SIZE * 0.015, TILE_SIZE * 0.015, TILE_SIZE * 0.1);
                    const appleStem = new THREE.Mesh(appleStemGeometry, new THREE.MeshPhongMaterial({ 
                        color: 0x6495ed,
                        emissive: 0x112244,
                        emissiveIntensity: 0.1
                    }));
                    appleStem.position.y = TILE_SIZE * 0.2;
                    appleGroup.add(apple);
                    appleGroup.add(appleStem);
                    return appleGroup;
                default:
                    return new THREE.Mesh(
                        new THREE.SphereGeometry(TILE_SIZE * 0.25, 16, 12),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x87ceeb, // Light blue
                            shininess: 60,
                            specular: 0x4482b4,
                            emissive: 0x223366,
                            emissiveIntensity: 0.1
                        })
                    );
            }
        }
        
        function spawnBonusFruit() {
            if (currentChapterIndex === 0) {
                spawnClassicBonusFruit();
            } else if (currentChapterIndex === 1) {
                spawnFrozenBonusFruit();
            }
        }
        
        function spawnClassicBonusFruit() {
            if (bonusFruit) return;
            const fruitTypes = ['cherry', 'strawberry', 'apple'];
            const fruitType = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
            const emptyTiles = [];
            const currentLevelMap = levelMaps[currentChapterIndex];
            for (let y = 0; y < currentLevelMap.length; y++) {
                for (let x = 0; x < currentLevelMap[y].length; x++) {
                    if (currentLevelMap[y][x] === 0) {
                        const worldPos = gridToWorld(x, y);
                        const occupied = powerups.some(p => 
                            Math.abs(p.position.x - worldPos.x) < TILE_SIZE * 0.5 && 
                            Math.abs(p.position.z - worldPos.z) < TILE_SIZE * 0.5
                        );
                        if (!occupied) {
                            emptyTiles.push({ x, y });
                        }
                    }
                }
            }
            if (emptyTiles.length === 0) return;
            const randomTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            const worldPos = gridToWorld(randomTile.x, randomTile.y);
            bonusFruit = createFruitGeometry(fruitType);
            bonusFruit.position.set(worldPos.x, TILE_SIZE * 0.4, worldPos.z); // Lowered from 0.6 to 0.4
            bonusFruit.userData = {
                type: 'bonus_fruit',
                fruitType: fruitType,
                points: 300,
                rotationSpeed: 0.05
            };
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.3 
            });
            const glowGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.45, 8, 6); // Slightly larger glow
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            bonusFruit.add(glow);
            mazeObjects.add(bonusFruit);
            bonusFruitTimer = 10000;
            console.log(`Bonus ${fruitType} spawned! ${bonusFruit.userData.points} points!`);
        }
        
        function spawnFrozenBonusFruit() {
            if (frozenFruit) return;
            const fruitTypes = ['cherry', 'strawberry', 'apple'];
            const fruitType = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
            const emptyTiles = [];
            const currentLevelMap = levelMaps[currentChapterIndex];
            for (let y = 0; y < currentLevelMap.length; y++) {
                for (let x = 0; x < currentLevelMap[y].length; x++) {
                    if (currentLevelMap[y][x] === 0) {
                        const worldPos = gridToWorld(x, y);
                        const occupied = powerups.some(p => 
                            Math.abs(p.position.x - worldPos.x) < TILE_SIZE * 0.5 && 
                            Math.abs(p.position.z - worldPos.z) < TILE_SIZE * 0.5
                        );
                        if (!occupied) {
                            emptyTiles.push({ x, y });
                        }
                    }
                }
            }
            if (emptyTiles.length === 0) return;
            const randomTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            const worldPos = gridToWorld(randomTile.x, randomTile.y);
            
            // Create light blue fruit using Chapter 1 fruit shapes
            frozenFruit = createFrozenFruitGeometry(fruitType);
            frozenFruit.position.set(worldPos.x, TILE_SIZE * 0.4, worldPos.z); // Lowered height for better collection
            frozenFruit.userData = {
                type: 'frozen_fruit',
                fruitType: fruitType,
                points: 300,
                requiredSpeed: playerSpeed * 1.2,
                rotationSpeed: 0.03
            };
            
            // Add sparkle effect around the snowflake
            const sparkleGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.5, 8, 6);
            const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.15 
            });
            const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
            frozenFruit.add(sparkle);
            
            mazeObjects.add(frozenFruit);
            frozenFruitTimer = 15000;
            console.log(`Frozen ${fruitType} spawned! ${frozenFruit.userData.points} points, slide fast to shatter!`);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameOver && gameStarted) {
                const delta = clock.getDelta();
                updatePlayer(delta);
                updateGhosts(delta);
                updateFlashFreeze(delta);
                updateIceCleats(delta);
                updateVineEntanglements(delta); // Update vine entanglement animations
                updateActivePowerups(delta * 1000); // Convert delta to milliseconds
                updateDashSystem(delta); // Update Adrenaline Dash system
                updateShieldSystem(delta); // Update Energy Shield system
                updateMonkeyDecoy(delta * 1000); // Update monkey decoy movement and timer
                updateDecoyUI(); // Update decoy status display
                updateDecoyUI(); // Update decoy status display
                updateDecoyUI(); // Update decoy status display

                
                // Animate powerup icons
                powerups.forEach(powerup => {
                    if (powerup.userData.rotationSpeed) {
                        // 3D rotation on multiple axes for 3D powerups
                        powerup.rotation.x += powerup.userData.rotationSpeed;
                        powerup.rotation.y += powerup.userData.rotationSpeed;
                        
                        // Add floating motion with unique phase
                        const time = Date.now() * 0.001;
                        powerup.position.y = TILE_SIZE / 2 + Math.sin(time * 2 + powerup.userData.floatOffset) * TILE_SIZE * 0.1;
                    }
                });
                
                // Animate monkey idols
                pellets.forEach(pellet => {
                    if (pellet.userData && pellet.userData.type === 'monkey-idol' && pellet.userData.animate && typeof pellet.userData.animate === 'function') {
                        try {
                            pellet.userData.animate(Date.now());
                        } catch (error) {
                            console.warn('Monkey idol animation error:', error);
                            // Remove the faulty animation function to prevent repeated errors
                            delete pellet.userData.animate;
                        }
                    }
                });
                
                checkCollisions();
                
                // Update powerup lifetimes and despawn expired ones
                updatePowerupLifetimes();
                
                // Controlled powerup spawning - try to maintain optimal count
                if (powerups.length < MAX_POWERUPS) {
                    spawnRandomPowerup();
                }
                
                // Handle shield timer
                if (shieldTimer > 0) {
                    shieldTimer -= delta;
                    if (shieldTimer <= 0) {
                        playerShield = false;
                        // Remove shield from active powerups display
                        const shieldToRemove = Array.from(activePowerups.entries()).find(([id, powerup]) => powerup.type === 'shield');
                        if (shieldToRemove) {
                            removeActivePowerup(shieldToRemove[0]);
                        }
                    }
                }
                
                if (powerUpTimer > 0) {
                    powerUpTimer -= delta;
                    if (powerUpTimer <= 0) {
                        ghosts.forEach(g => {
                            if (g.userData.state === 'frightened') g.userData.state = 'chasing';
                        });
                    }
                }
                
                // Handle bonus fruit timers
                if (bonusFruitTimer > 0) {
                    bonusFruitTimer -= delta * 1000; // Convert to milliseconds
                    if (bonusFruitTimer <= 0 && bonusFruit) {
                        mazeObjects.remove(bonusFruit);
                        bonusFruit = null;
                        console.log("Classic bonus fruit disappeared!");
                    }
                }
                
                if (frozenFruitTimer > 0) {
                    frozenFruitTimer -= delta * 1000; // Convert to milliseconds
                    if (frozenFruitTimer <= 0 && frozenFruit) {
                        mazeObjects.remove(frozenFruit);
                        frozenFruit = null;
                        console.log("Frozen bonus fruit melted away!");
                    }
                }
                
                // Animate bonus fruits
                if (bonusFruit && bonusFruit.userData.rotationSpeed) {
                    bonusFruit.rotation.y += bonusFruit.userData.rotationSpeed;
                    const time = Date.now() * 0.001;
                    bonusFruit.position.y = TILE_SIZE * 0.4 + Math.sin(time * 3) * TILE_SIZE * 0.05; // Updated base height
                }
                
                if (frozenFruit && frozenFruit.userData.rotationSpeed) {
                    frozenFruit.rotation.y += frozenFruit.userData.rotationSpeed;
                    const time = Date.now() * 0.001;
                    frozenFruit.position.y = TILE_SIZE * 0.4 + Math.sin(time * 2) * TILE_SIZE * 0.03; // Updated base height
                }
                
                // Randomly spawn bonus fruits during gameplay
                if (Math.random() < 0.0008) { // Slightly less frequent than powerups
                    spawnBonusFruit();
                }
                
                if (levelTimer > 0) {
                    levelTimer -= delta;
                } else {
                    levelTimer = 0;
                    handlePlayerDeath();
                }
                
                updateUI();
                
                if (player) {
                    const camOffset = new THREE.Vector3(0, 8, 7);
                    camera.position.lerp(player.position.clone().add(camOffset), 0.1);
                    camera.lookAt(player.position);
                    
                    // Shield visual effect
                    if (playerShield) {
                        player.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x00ff00);
                                child.material.emissiveIntensity = Math.sin(clock.getElapsedTime() * 10) * 0.3 + 0.2;
                            }
                        });
                    } else {
                        player.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        });
                    }
                }
                
                const pulse = Math.sin(clock.getElapsedTime() * 3) * 0.2 + 0.9;
                powerPellets.forEach(p => p.scale.set(pulse, pulse, pulse));
            }
            
            renderer.render(scene, camera);
        }

        // --- LEVEL & CHAPTER MANAGEMENT ---
        function clearLevel() {
            // Clear all game objects from the scene
            mazeObjects.clear();
            
            // Clear ice theme effects if they exist
            const toRemove = [];
            scene.traverse(function(child) {
                if (child.userData && (child.userData.isIceLight || child.userData.isIceParticle)) {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(obj => scene.remove(obj));
            
            // Reset arrays
            ghosts = [];
            pellets = [];
            powerPellets = [];
            powerups = [];
            stickyBlocks = [];
            
            // Reset player
            player = null;
            
            // Reset sticky block state
            playerSpeedModifier = 1.0;
            isPlayerOnStickyBlock = false;
            
            // Reset powerup effects
            playerShield = false;
            shieldTimer = 0;
            playerSpeed = BASE_PLAYER_SPEED;
            iceWallCharges = 0;
            flashFreezeActive = false;
            flashFreezeTimer = 0;
            iceCleatsActive = false;
            iceCleatsTimer = 0;
            snareSeedCharges = 0; // Reset snare seed charges
            clearAllActivePowerups(); // Clear powerup display
            
            // Remove frost aura if it exists
            if (frostAura && frostAura.parent) {
                frostAura.parent.remove(frostAura);
                frostAura = null;
            }
            
            // Remove traction aura if it exists
            if (tractionAura && tractionAura.parent) {
                tractionAura.parent.remove(tractionAura);
                tractionAura = null;
            }
            
            // Clear temporary ice blocks
            temporaryIceBlocks.forEach(block => {
                if (block.parent) {
                    block.parent.remove(block);
                }
            });
            temporaryIceBlocks = [];
            
            // Clear active snare seed traps
            activeSnareSeedTraps.forEach(trap => {
                if (trap.parent) {
                    trap.parent.remove(trap);
                }
            });
            activeSnareSeedTraps = [];
            
            // Clear vine entanglements
            scene.traverse((child) => {
                if (child.userData && child.userData.isVineEntanglement) {
                    scene.remove(child);
                }
            });
        }

        function startChapterRun(startLevelIndex) {
            currentLevelIndexInChapter = startLevelIndex;
            const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];
            
            // Load the level first to show map in background
            initializeLevelForTutorial(startLevelIndex);
            
            // Show appropriate tutorial based on chapter
            if (currentChapterIndex === 0) {
                // Chapter 1 - show normal powerup tutorial
                tutorialTargetScoreEl.textContent = levelConfig.targetScore;
                levelSelectScreen.style.display = 'none';
                
                // Small delay to ensure level is rendered before applying blur
                setTimeout(() => {
                    powerupTutorialScreen.style.display = 'block';
                    renderer.domElement.style.filter = 'blur(8px)';
                    uiContainer.style.opacity = 0; // Hide UI during tutorial
                }, 100);
                
            } else if (currentChapterIndex === 1) {
                // Chapter 2 - show ice powerup tutorial
                tutorial2TargetScoreEl.textContent = levelConfig.targetScore;
                levelSelectScreen.style.display = 'none';
                
                // Small delay to ensure level is rendered before applying blur
                setTimeout(() => {
                    powerupTutorial2Screen.style.display = 'block';
                    renderer.domElement.style.filter = 'blur(8px)';
                    uiContainer.style.opacity = 0; // Hide UI during tutorial
                }, 100);
                
            } else if (currentChapterIndex === 2) {
                // Chapter 3 - show jungle controls tutorial
                levelSelectScreen.style.display = 'none';
                
                // Small delay to ensure level is rendered before applying blur
                setTimeout(() => {
                    const controlsTutorial3Screen = document.getElementById('controls-tutorial-3-screen');
                    controlsTutorial3Screen.style.display = 'block';
                    renderer.domElement.style.filter = 'blur(8px)';
                    uiContainer.style.opacity = 0; // Hide UI during tutorial
                }, 100);
                
            } else {
                // Chapter 4 and beyond, go directly to game
                levelSelectScreen.style.display = 'none';
                startGameDirectly();
            }
        }
        
        // Function to load and render level for tutorial background
        function initializeLevelForTutorial(levelIndex) {
            currentLevelIndexInChapter = levelIndex;
            const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];

            // Clear any existing level
            clearLevel();
            
            // Reset game state
            score = 0;
            lives = 5;
            playerSpeed = BASE_PLAYER_SPEED;
            ghostSpeedModifier = 1.0;
            gameOver = false;
            gameStarted = false; // Important: don't start the game loop yet

            // Initialize Adrenaline Dash system
            dashCooldown = 0;
            dashActive = false;
            dashTimer = 0;
            dashParticles = [];
            
            // Reset ice physics for Chapter 2
            if (currentChapterIndex === 1) {
                resetIcePhysics();
            }
            
            levelTimer = levelConfig.timeLimit;
            powerUpTimer = 0;
            
            // Apply sacrifices from previous level (if any)
            let adjustedTimeLimit = levelConfig.timeLimit - timeReductionNextLevel;
            let adjustedTargetScore = Math.ceil(levelConfig.targetScore * targetScoreIncreaseNextLevel);
            
            levelTimer = adjustedTimeLimit;
            
            // Create the level properly using the same logic as startLevel
            const currentLevelConfig = {
                ...levelConfig,
                timeLimit: adjustedTimeLimit,
                targetScore: adjustedTargetScore,
                powerUpDuration: Math.ceil(levelConfig.powerUpDuration * powerupDurationReduction)
            };
            
            // Create the maze and entities
            createMaze();
            createGhosts(currentLevelConfig.ghostCount, currentLevelConfig.ghostSpeed);
            
            // Set up camera position manually
            if (player) {
                const camOffset = new THREE.Vector3(0, 8, 7);
                const targetPos = player.position.clone().add(camOffset);
                camera.position.copy(targetPos);
                camera.lookAt(player.position);
            }
            
            // Update UI elements
            updateUI();
            
            // Clear all active powerups display
            clearAllActivePowerups();
            
            // Apply starting powerup if selected
            if (selectedPowerupType) {
                applyStartingPowerup(selectedPowerupType);
                selectedPowerupType = null;
            }
            
            // Don't spawn powerups/fruits during tutorial
            // Start a basic render loop for tutorial background (without game logic)
            startTutorialRenderLoop();
            
            console.log(`Level ${levelIndex + 1} loaded for tutorial background`);
        }
        
        // Simple render loop for tutorial background
        let tutorialRenderLoop = null;
        function startTutorialRenderLoop() {
            if (tutorialRenderLoop) {
                cancelAnimationFrame(tutorialRenderLoop);
            }
            
            function renderTutorial() {
                // Only render, don't update game logic
                renderer.render(scene, camera);
                
                // Continue loop if we're still in tutorial mode
                if (!gameStarted) {
                    tutorialRenderLoop = requestAnimationFrame(renderTutorial);
                }
            }
            
            renderTutorial();
        }
        
        function stopTutorialRenderLoop() {
            if (tutorialRenderLoop) {
                cancelAnimationFrame(tutorialRenderLoop);
                tutorialRenderLoop = null;
            }
        }
        
        // New function to start game without tutorial
        function startGameDirectly() {
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            score = 0;
            lives = 5;
            playerSpeed = BASE_PLAYER_SPEED;
            ghostSpeedModifier = 1.0;
            gameOver = false;

            // Initialize Adrenaline Dash system
            dashCooldown = 0;
            dashActive = false;
            dashTimer = 0;
            dashParticles = [];
            updateDashDisplay();

            startLevel(currentLevelIndexInChapter);

            // Hide all UI screens to show the game
            homeScreen.style.display = 'none';
            chapterSelectScreen.style.display = 'none';
            levelSelectScreen.style.display = 'none';
            powerupTutorialScreen.style.display = 'none';
            powerupTutorial2Screen.style.display = 'none';
            controlsTutorialScreen.style.display = 'none';
            controlsTutorial2Screen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            chapterCompleteScreen.style.display = 'none';
            settingsScreen.style.display = 'none';
            instructionsScreen.style.display = 'none';

            uiContainer.style.opacity = 1;
            gameStarted = true;
        }

        // Add new function to actually start the game after tutorial
        function startGameAfterTutorial() {
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            score = 0;
            lives = 5;
            playerSpeed = BASE_PLAYER_SPEED;
            ghostSpeedModifier = 1.0;
            gameOver = false;

            // Initialize Adrenaline Dash system
            dashCooldown = 0;
            dashActive = false;
            dashTimer = 0;
            dashParticles = [];
            updateDashDisplay();

            startLevel(currentLevelIndexInChapter);

            // Hide all UI screens to show the game
            homeScreen.style.display = 'none';
            chapterSelectScreen.style.display = 'none';
            levelSelectScreen.style.display = 'none';
            powerupTutorialScreen.style.display = 'none';
            powerupTutorial2Screen.style.display = 'none';
            controlsTutorialScreen.style.display = 'none';
            controlsTutorial2Screen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            chapterCompleteScreen.style.display = 'none';
            settingsScreen.style.display = 'none';
            instructionsScreen.style.display = 'none';
            
            uiContainer.style.opacity = 1;
            gameStarted = true;
        }

        function startLevel(levelIndex) {
            clearLevel();
            currentLevelIndexInChapter = levelIndex;
            const levelConfig = chapters[currentChapterIndex][currentLevelIndexInChapter];

            // Reset score to 0 at the start of each level
            score = 0;
            scoreAtLevelStart = 0;
            livesAtLevelStart = lives;
            
            // Reset ice physics for Chapter 2
            if (currentChapterIndex === 1) {
                resetIcePhysics();
            }
            
            // Reset ice physics for Chapter 2
            if (currentChapterIndex === 1) {
                resetIcePhysics();
            }
            
            // Apply sacrifices from previous level
            let adjustedTimeLimit = levelConfig.timeLimit - timeReductionNextLevel;
            let adjustedTargetScore = Math.ceil(levelConfig.targetScore * targetScoreIncreaseNextLevel);
            
            levelTimer = adjustedTimeLimit;
            powerUpTimer = 0;
            
            // Update the level config temporarily for this level
            const currentLevelConfig = {
                ...levelConfig,
                timeLimit: adjustedTimeLimit,
                targetScore: adjustedTargetScore,
                powerUpDuration: Math.ceil(levelConfig.powerUpDuration * powerupDurationReduction)
            };
            
            // Store modified config temporarily
            chapters[currentChapterIndex][currentLevelIndexInChapter] = currentLevelConfig;

            createMaze();
            createGhosts(levelConfig.ghostCount, levelConfig.ghostSpeed * ghostSpeedModifier);
            
            // Apply starting powerup if selected
            if (selectedPowerupType) {
                setTimeout(() => {
                    applyStartingPowerup();
                }, 500); // Small delay to ensure everything is initialized
            }
            
            // Reset sacrifice values after applying them
            timeReductionNextLevel = 0;
            targetScoreIncreaseNextLevel = 1.0;
            powerupDurationReduction = 1.0;
            
            updateUI();
        }

        function returnToLevelSelect() {
            gameStarted = false;
            gameOver = true;
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            updateLevelSelectUI();
            levelSelectScreen.style.display = 'block';
            uiContainer.style.opacity = 0;
            clearLevel();
        }
        
        function returnToChapterSelect() {
            gameStarted = false;
            gameOver = true;
            chapterCompleteScreen.style.display = 'none';
            chapterSelectScreen.style.display = 'block';
            uiContainer.style.opacity = 0;
            clearLevel();
        }

        function showChapterLevels(chapterIndex) {
            currentChapterIndex = chapterIndex;
            chapterSelectScreen.style.display = 'none';
            levelSelectScreen.style.display = 'block';
            
            // Clear all powerups from Chapter 1 when entering Chapter 2
            if (chapterIndex === 1) {
                // Clear powerups from scene
                powerups.forEach(powerup => {
                    if (powerup.parent) {
                        powerup.parent.remove(powerup);
                    }
                });
                // Reset powerup array
                powerups = [];
                
                // Reset any active powerup effects from Chapter 1
                playerShield = false;
                shieldTimer = 0;
                playerSpeed = BASE_PLAYER_SPEED;
                ghostSpeedModifier = 1.0;
                
                console.log('Chapter 2: Cleared all Chapter 1 powerups');
            }
            
            // Clear all Chapter 2 specific effects when entering Chapter 3
            if (chapterIndex === 2) {
                // Clear powerups from scene
                powerups.forEach(powerup => {
                    if (powerup.parent) {
                        powerup.parent.remove(powerup);
                    }
                });
                // Reset powerup array
                powerups = [];
                
                // Reset Chapter 2 specific effects
                iceWallCharges = 0;
                flashFreezeActive = false;
                flashFreezeTimer = 0;
                iceCleatsActive = false;
                iceCleatsTimer = 0;
                temporaryIceBlocks = [];
                frozenFruit = null;
                frozenFruitTimer = 0;
                
                // Remove any visual effects
                if (frostAura) {
                    scene.remove(frostAura);
                    frostAura = null;
                }
                if (tractionAura) {
                    scene.remove(tractionAura);
                    tractionAura = null;
                }
                
                // Reset basic stats
                playerShield = false;
                shieldTimer = 0;
                playerSpeed = BASE_PLAYER_SPEED;
                ghostSpeedModifier = 1.0;
                
                console.log('Chapter 3: Cleared all Chapter 2 effects');
            }
            
            // Update chapter title
            document.getElementById('chapter-title').textContent = `Chapter ${chapterIndex + 1}`;
            
            updateLevelSelectUI();
        }

        function updateLevelSelectUI() {
            document.querySelectorAll('.level-button').forEach(button => {
                const levelNum = parseInt(button.dataset.level) + 1;
                if (levelNum > highestUnlockedLevel) {
                    button.classList.add('locked');
                    button.disabled = true;
                } else {
                    button.classList.remove('locked');
                    button.disabled = false;
                }
            });
        }

        // --- EVENT LISTENERS ---
        // Ensure elements exist before adding listeners
        const startGameBtn = document.getElementById('start-game-home-button');
        if (startGameBtn) {
            startGameBtn.addEventListener('click', () => {
                console.log('Start game button clicked!');
                homeScreen.style.display = 'none';
                chapterSelectScreen.style.display = 'block';
                console.log('Screens updated');
            });
        } else {
            console.error('Start game button not found!');
        }

        const settingsBtn = document.getElementById('settings-button');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                settingsScreen.style.display = 'block';
                homeScreen.style.display = 'none';
            });
        }

        document.getElementById('instructions-button').addEventListener('click', () => {
            instructionsScreen.style.display = 'block';
            homeScreen.style.display = 'none';
        });

        document.getElementById('back-to-home-button').addEventListener('click', () => {
            homeScreen.style.display = 'block';
            settingsScreen.style.display = 'none';
            instructionsScreen.style.display = 'none';
        });

        document.getElementById('save-settings-button').addEventListener('click', () => {
            saveSettings();
            settingsScreen.style.display = 'none';
            homeScreen.style.display = 'block';
        });

        document.getElementById('reset-settings-button').addEventListener('click', () => {
            masterVolume = 0.5;
            sfxVolume = 0.7;
            audioMuted = false;
            gameDifficulty = 'normal';
            cameraStyle = 'follow';
            showFPS = false;
            graphicsQuality = 'medium';
            shadowsEnabled = true;
            particlesEnabled = true;
            updateSettingsUI();
        });

        document.getElementById('back-to-home-from-instructions-button').addEventListener('click', () => {
            homeScreen.style.display = 'block';
            instructionsScreen.style.display = 'none';
        });

        document.getElementById('back-to-home-from-chapters-button').addEventListener('click', () => {
            chapterSelectScreen.style.display = 'none';
            homeScreen.style.display = 'block';
        });

        document.getElementById('back-to-chapters-button').addEventListener('click', () => {
            levelSelectScreen.style.display = 'none';
            chapterSelectScreen.style.display = 'block';
        });

        document.getElementById('restart-button').addEventListener('click', () => {
            returnToLevelSelect();
        });

        document.getElementById('level-menu-button').addEventListener('click', () => {
            returnToLevelSelect();
        });

        document.getElementById('back-to-menu-button').addEventListener('click', () => {
            returnToLevelSelect();
        });

        // Powerup tutorial buttons
        document.getElementById('start-game-button').addEventListener('click', () => {
            powerupTutorialScreen.style.display = 'none';
            controlsTutorialScreen.style.display = 'block';
            // Keep the blur effect for controls tutorial
        });

        document.getElementById('skip-tutorial-button').addEventListener('click', () => {
            powerupTutorialScreen.style.display = 'none';
            // Remove blur effect and start the game directly
            renderer.domElement.style.filter = 'none';
            uiContainer.style.opacity = 1;
            
            // Stop tutorial render loop and start main game
            stopTutorialRenderLoop();
            gameStarted = true;
            
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            updateDashDisplay();
        });

        // Chapter 2 tutorial button handlers
        document.getElementById('start-game-2-button').addEventListener('click', () => {
            powerupTutorial2Screen.style.display = 'none';
            controlsTutorial2Screen.style.display = 'block';
            // Keep the blur effect for controls tutorial
        });

        document.getElementById('skip-tutorial-2-button').addEventListener('click', () => {
            powerupTutorial2Screen.style.display = 'none';
            // Remove blur effect and start the game directly
            renderer.domElement.style.filter = 'none';
            uiContainer.style.opacity = 1;
            
            // Stop tutorial render loop and start main game
            stopTutorialRenderLoop();
            gameStarted = true;
            
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            updateDashDisplay();
        });

        // Controls tutorial button handlers
        document.getElementById('start-game-from-controls').addEventListener('click', () => {
            controlsTutorialScreen.style.display = 'none';
            // Remove blur effect and start the game
            renderer.domElement.style.filter = 'none';
            uiContainer.style.opacity = 1;
            
            // Stop tutorial render loop and start main game
            stopTutorialRenderLoop();
            gameStarted = true;
            
            // Start audio and update dash display
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            updateDashDisplay();
        });

        document.getElementById('start-game-from-controls-2').addEventListener('click', () => {
            controlsTutorial2Screen.style.display = 'none';
            // Remove blur effect and start the game
            renderer.domElement.style.filter = 'none';
            uiContainer.style.opacity = 1;
            
            // Stop tutorial render loop and start main game
            stopTutorialRenderLoop();
            gameStarted = true;
            
            // Start audio and update dash display
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            updateDashDisplay();
        });

        document.getElementById('start-game-from-controls-3').addEventListener('click', () => {
            const controlsTutorial3Screen = document.getElementById('controls-tutorial-3-screen');
            controlsTutorial3Screen.style.display = 'none';
            // Remove blur effect and start the game
            renderer.domElement.style.filter = 'none';
            uiContainer.style.opacity = 1;
            
            // Stop tutorial render loop and start the game directly
            stopTutorialRenderLoop();
            
            // Start the game directly without going through tutorials again
            const levelIndex = window.selectedLevelIndex || 0;
            currentLevelIndexInChapter = levelIndex;
            startGameDirectly();
            
            // Start audio and update dash display
            try { Tone.start(); } catch(e) { console.log('Audio start failed:', e); }
            updateDashDisplay();
        });

        // Initialize DOM elements and event listeners after DOM is ready
        function initializeEventListeners() {
            // Initialize all DOM element references
            scoreEl = document.getElementById('score');
            livesEl = document.getElementById('lives');
            levelEl = document.getElementById('level-display');
            timerEl = document.getElementById('timer');
            chapterSelectScreen = document.getElementById('chapter-select-screen');
            levelSelectScreen = document.getElementById('level-select-screen');
            gameOverScreen = document.getElementById('game-over-screen');
            levelCompleteScreen = document.getElementById('level-complete-screen');
            chapterCompleteScreen = document.getElementById('chapter-complete-screen');
            finalScoreEl = document.getElementById('final-score');
            levelCompleteStatsEl = document.getElementById('level-complete-stats');
            performanceStarsEl = document.getElementById('performance-stars');
            chapterCompleteScoreEl = document.getElementById('chapter-complete-score');
            advantageChoicesEl = document.getElementById('advantage-choices');
            sacrificeChoicesEl = document.getElementById('sacrifice-choices');
            disadvantageChoicesEl = document.getElementById('disadvantage-choices');
            
            // Chapter select buttons
            document.querySelectorAll('.chapter-button').forEach(button => {
                button.addEventListener('click', () => {
                    const chapterIndex = parseInt(button.dataset.chapter);
                    currentChapterIndex = chapterIndex;
                    console.log(`Chapter ${chapterIndex + 1} selected`);
                    
                    // Always show level selection first for all chapters
                    showChapterLevels(chapterIndex);
                });
            });

            // Level select buttons
            document.querySelectorAll('.level-button').forEach(button => {
                button.addEventListener('click', () => {
                    const levelIndex = parseInt(button.dataset.level);
                    if (button.classList.contains('locked')) return;
                    console.log(`Level ${levelIndex + 1} selected`);
                    
                    // For Chapter 3, show power-up tutorial first
                    if (currentChapterIndex === 2) {
                        // Store the selected level index for later use
                        window.selectedLevelIndex = levelIndex;
                        showChapter3Powerups();
                    } else {
                        startChapterRun(levelIndex);
                    }
                });
            });

            // Settings button
            document.getElementById('settings-button')?.addEventListener('click', () => {
                document.getElementById('home-screen').style.display = 'none';
                document.getElementById('settings-screen').style.display = 'block';
            });

            // Instructions button
            document.getElementById('instructions-button')?.addEventListener('click', () => {
                document.getElementById('home-screen').style.display = 'none';
                document.getElementById('instructions-screen').style.display = 'block';
            });
            
            console.log('Event listeners and DOM elements initialized successfully');
        }

        // Wait for DOM to be ready before setting up event listeners
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeEventListeners);
        } else {
            initializeEventListeners();
        }

        // Advantage choice buttons
        document.getElementById('increase-speed-button').addEventListener('click', () => {
            playerSpeed *= 1.1; // 10% speed increase
            console.log('Player speed increased by 10%!');
            proceedToNextLevel();
        });

        document.getElementById('extra-life-button').addEventListener('click', () => {
            lives += 1;
            console.log('Extra life granted!');
            proceedToNextLevel();
        });

        document.getElementById('choose-powerup-button').addEventListener('click', () => {
            levelCompleteScreen.style.display = 'none';
            document.getElementById('powerup-selection-screen').style.display = 'block';
        });

        // Disadvantage choice buttons
        document.getElementById('lose-life-button').addEventListener('click', () => {
            lives = Math.max(1, lives - 1); // Don't go below 1 life
            console.log('Life lost as penalty!');
            proceedToNextLevel();
        });

        document.getElementById('decrease-speed-button').addEventListener('click', () => {
            playerSpeed *= 0.9; // 10% speed decrease
            console.log('Player speed decreased by 10%!');
            proceedToNextLevel();
        });

        document.getElementById('increase-ghost-speed-button').addEventListener('click', () => {
            ghostSpeedModifier *= 1.1; // 10% ghost speed increase
            console.log('Ghost speed increased by 10%!');
            proceedToNextLevel();
        });

        document.getElementById('no-powerups-button').addEventListener('click', () => {
            noPowerupsNextLevel = true;
            console.log('No powerups will appear in the next level!');
            proceedToNextLevel();
        });

        // Sacrifice choice buttons (2-star performance)
        document.getElementById('sacrifice-speed-button').addEventListener('click', () => {
            playerSpeed *= 0.95; // 5% speed decrease
            console.log('Player speed reduced by 5% as sacrifice!');
            proceedToNextLevel();
        });

        document.getElementById('sacrifice-time-button').addEventListener('click', () => {
            timeReductionNextLevel = 10; // 10 seconds less in next level
            console.log('Next level will have 10 seconds less time!');
            proceedToNextLevel();
        });

        document.getElementById('sacrifice-score-button').addEventListener('click', () => {
            targetScoreIncreaseNextLevel = 1.1; // 10% higher target score
            console.log('Next level target score increased by 10%!');
            proceedToNextLevel();
        });

        document.getElementById('sacrifice-powerup-duration-button').addEventListener('click', () => {
            powerupDurationReduction = 0.75; // 25% shorter powerup effects
            console.log('Powerup effects will be 25% shorter in next level!');
            proceedToNextLevel();
        });

        // Powerup selection buttons
        document.querySelectorAll('.select-powerup-button').forEach(button => {
            button.addEventListener('click', () => {
                selectedPowerupType = button.dataset.powerup;
                console.log(`Selected powerup: ${selectedPowerupType}`);
                document.getElementById('powerup-selection-screen').style.display = 'none';
                proceedToNextLevel();
            });
        });

        document.getElementById('cancel-powerup-selection').addEventListener('click', () => {
            document.getElementById('powerup-selection-screen').style.display = 'none';
            levelCompleteScreen.style.display = 'block';
        });

        // Add keyboard controls
        document.addEventListener('keydown', (event) => {
            if (gameStarted && player) {
                const desiredDirection = new THREE.Vector3(0, 0, 0);
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        desiredDirection.set(0, 0, -1);
                        event.preventDefault();
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        desiredDirection.set(0, 0, 1);
                        event.preventDefault();
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        desiredDirection.set(-1, 0, 0);
                        event.preventDefault();
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        desiredDirection.set(1, 0, 0);
                        event.preventDefault();
                        break;
                    case 'Enter':
                        // Skip tutorial or modals
                        if (powerupTutorialScreen.style.display === 'block') {
                            startGameAfterTutorial();
                            event.preventDefault();
                        }
                        break;
                    case 'Escape':
                        // Quick back navigation
                        event.preventDefault();
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        // Activate dash
                        if (dashCooldown <= 0 && !dashActive) {
                            activateDash();
                        }
                        event.preventDefault();
                        break;
                    case 'KeyE':
                        // Activate energy shield
                        if (shieldCooldown <= 0 && !isShieldActive) {
                            activateEnergyShield();
                        }
                        event.preventDefault();
                        break;
                    case 'KeyF':
                        // Chapter 3: Handle Monkey Decoy and Snare Seed
                        if (currentChapterIndex === 2) {
                            // Priority: Monkey Decoy first, then Snare Seed
                            if (hasDecoy && !activeDecoy) {
                                deployMonkeyDecoy();
                            } else if (snareSeedCharges > 0) {
                                placeSnareSeed();
                            } else {
                                console.log('⚠️ No decoys or snare seeds available!');
                            }
                        }
                        event.preventDefault();
                        break;
                }
                if (player.userData && !desiredDirection.equals(new THREE.Vector3(0, 0, 0))) {
                    player.userData.desiredDirection = desiredDirection;
                }
            }
        });

        // Flash Freeze mechanics for Chapter 2
        function createFrostAura() {
            // Remove existing aura if it exists
            if (frostAura && frostAura.parent) {
                frostAura.parent.remove(frostAura);
            }
            
            // Create frost aura visual effect
            const auraRadius = TILE_SIZE * 3; // 3 tile radius
            const geometry = new THREE.RingGeometry(auraRadius * 0.8, auraRadius, 16, 1);
            const material = new THREE.MeshBasicMaterial({
                color: '#b0e0e6',
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            frostAura = new THREE.Mesh(geometry, material);
            frostAura.rotation.x = -Math.PI / 2; // Lay flat on ground
            frostAura.position.y = 0.1; // Slightly above ground
            
            // Add to player so it follows
            player.add(frostAura);
            
            // Add pulsing animation
            frostAura.userData.pulseTime = 0;
            
            console.log('Frost aura created with radius:', auraRadius);
        }
        
        function updateFlashFreeze(delta) {
            if (!flashFreezeActive) return;
            
            // Update timer
            flashFreezeTimer -= delta * 1000; // Convert to milliseconds
            
            if (flashFreezeTimer <= 0) {
                // Deactivate flash freeze
                flashFreezeActive = false;
                flashFreezeTimer = 0;
                
                // Remove from active powerups display
                const freezeToRemove = Array.from(activePowerups.entries()).find(([id, powerup]) => powerup.type === 'flash_freeze');
                if (freezeToRemove) {
                    removeActivePowerup(freezeToRemove[0]);
                }
                
                // Remove frost aura
                if (frostAura && frostAura.parent) {
                    frostAura.parent.remove(frostAura);
                    frostAura = null;
                }
                
                console.log('Flash Freeze effect ended');
                return;
            }
            
            // Update frost aura animation
            if (frostAura) {
                frostAura.userData.pulseTime += delta * 2;
                const pulse = Math.sin(frostAura.userData.pulseTime) * 0.1 + 0.3;
                frostAura.material.opacity = pulse;
                
                // Slight rotation for visual effect
                frostAura.rotation.z += delta * 0.5;
            }
            
            // Check which ghosts are within frost radius and slow them
            const auraRadius = TILE_SIZE * 3;
            const playerPos = player.position;
            
            ghosts.forEach(ghost => {
                const distance = ghost.position.distanceTo(playerPos);
                
                if (distance <= auraRadius) {
                    // Ghost is in frost aura - apply slow effect
                    if (!ghost.userData.frosted) {
                        ghost.userData.frosted = true;
                        ghost.userData.originalSpeed = ghost.userData.speed || 1.5;
                        ghost.userData.speed = ghost.userData.originalSpeed * 0.5; // 50% speed reduction
                        
                        // Visual effect - make ghost slightly blue
                        if (ghost.material) {
                            ghost.material.emissive.setHex(0x0000ff);
                            ghost.material.emissiveIntensity = 0.2;
                        }
                    }
                } else {
                    // Ghost is outside frost aura - restore normal speed
                    if (ghost.userData.frosted) {
                        ghost.userData.frosted = false;
                        ghost.userData.speed = ghost.userData.originalSpeed || 1.5;
                        
                        // Remove visual effect
                        if (ghost.material) {
                            ghost.material.emissive.setHex(0x000000);
                            ghost.material.emissiveIntensity = 0;
                        }
                    }
                }
            });
        }
        
        // Create traction aura for Ice Cleats
        function createTractionAura() {
            // Remove existing traction aura
            if (tractionAura && tractionAura.parent) {
                tractionAura.parent.remove(tractionAura);
            }
            
            // Create white aura geometry (similar to frost but white)
            const geometry = new THREE.RingGeometry(TILE_SIZE * 0.8, TILE_SIZE * 1.5, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff, // White color for traction
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            
            tractionAura = new THREE.Mesh(geometry, material);
            tractionAura.rotation.x = -Math.PI / 2; // Lay flat on ground
            tractionAura.position.y = 0.1; // Slightly above ground
            
            // Add to player
            player.add(tractionAura);
            
            // Initialize animation properties
            tractionAura.userData.pulseTime = 0;
        }
        
        // Update Ice Cleats system
        function updateIceCleats(delta) {
            if (!iceCleatsActive) return;
            
            // Update timer
            iceCleatsTimer -= delta * 1000;
            
            if (iceCleatsTimer <= 0) {
                // Deactivate ice cleats
                iceCleatsActive = false;
                iceCleatsTimer = 0;
                
                // Remove from active powerups display
                const cleatsToRemove = Array.from(activePowerups.entries()).find(([id, powerup]) => powerup.type === 'ice_cleats');
                if (cleatsToRemove) {
                    removeActivePowerup(cleatsToRemove[0]);
                }
                
                // Remove traction aura
                if (tractionAura && tractionAura.parent) {
                    tractionAura.parent.remove(tractionAura);
                    tractionAura = null;
                }
                
                console.log('Ice Cleats effect ended');
                return;
            }
            
            // Update traction aura animation
            if (tractionAura) {
                tractionAura.userData.pulseTime += delta * 2;
                const pulse = Math.sin(tractionAura.userData.pulseTime) * 0.1 + 0.5;
                tractionAura.material.opacity = pulse;
                
                // Opposite rotation from frost for distinction
                tractionAura.rotation.z -= delta * 0.7;
            }
        }

        // Snare Seed mechanics for Chapter 3
        function updateSnareSeedUI() {
            // Update UI to show snare seed charges (could add visual indicator later)
            console.log(`Snare Seed charges: ${snareSeedCharges}`);
        }
        
        // 🐒 UI Management for Monkey Decoy
        function updateDecoyUI() {
            const decoyStatus = document.getElementById('decoy-status');
            
            if (currentChapterIndex === 2) { // Only show in Chapter 3
                decoyStatus.style.display = 'block';
                
                if (activeDecoy) {
                    // Decoy is currently active
                    const timeLeft = Math.ceil(decoyTimer / 1000);
                    decoyStatus.textContent = `🐒 DECOY ACTIVE (${timeLeft}s)`;
                    decoyStatus.className = 'active';
                } else if (hasDecoy) {
                    // Player has a decoy ready to deploy
                    decoyStatus.textContent = '🐒 DECOY READY';
                    decoyStatus.className = 'ready';
                } else {
                    // No decoy available
                    decoyStatus.textContent = '🐒 NO DECOY';
                    decoyStatus.className = 'not-ready';
                }
            } else {
                // Hide in other chapters
                decoyStatus.style.display = 'none';
            }
        }

        function placeSnareSeed() {
            if (snareSeedCharges <= 0) {
                console.log('No snare seed charges available!');
                return;
            }
            
            if (currentChapterIndex !== 2) {
                console.log('Snare seeds only work in Chapter 3!');
                return;
            }
            
            // Get player's current grid position
            const playerGrid = worldToGrid(player.position.x, player.position.z);
            const playerGridX = playerGrid.x;
            const playerGridZ = playerGrid.y; // Note: worldToGrid returns {x, y} where y is the Z coordinate
            
            console.log(`Player position: (${player.position.x.toFixed(2)}, ${player.position.z.toFixed(2)})`);
            console.log(`Player grid: (${playerGridX}, ${playerGridZ})`);
            
            // Determine position directly behind player based on their facing direction
            let trapGridX = playerGridX;
            let trapGridZ = playerGridZ;
            
            // Get player's movement direction to place trap behind them
            const direction = player.userData.direction || new THREE.Vector3(0, 0, 1);
            
            if (Math.abs(direction.x) > Math.abs(direction.z)) {
                // Moving horizontally, place behind in opposite direction
                if (direction.x > 0) {
                    // Moving right, place trap to the left
                    trapGridX = playerGridX - 1;
                } else {
                    // Moving left, place trap to the right
                    trapGridX = playerGridX + 1;
                }
            } else {
                // Moving vertically, place behind in opposite direction
                if (direction.z > 0) {
                    // Moving forward (positive Z), place trap behind (negative Z)
                    trapGridZ = playerGridZ - 1;
                } else {
                    // Moving backward (negative Z), place trap ahead (positive Z)
                    trapGridZ = playerGridZ + 1;
                }
            }
            
            console.log(`Placing snare seed at grid: (${trapGridX}, ${trapGridZ})`);
            
            // Try to place the snare seed trap
            if (createSnareSeedTrap(trapGridX, trapGridZ)) {
                snareSeedCharges--;
                updateSnareSeedUI();
                console.log(`Snare seed placed! Remaining charges: ${snareSeedCharges}`);
            } else {
                console.log('Cannot place snare seed at that location!');
            }
        }

        function createSnareSeedTrap(gridX, gridY) {
            // Get current level map
            const currentLevelMap = levelMaps[currentChapterIndex];
            
            // Check if position is valid and not already occupied
            if (gridY < 0 || gridY >= currentLevelMap.length || 
                gridX < 0 || gridX >= currentLevelMap[gridY].length) {
                console.log(`Position (${gridX}, ${gridY}) is out of bounds`);
                return false;
            }
            
            // Don't place on walls
            if (currentLevelMap[gridY][gridX] === 1) {
                console.log(`Position (${gridX}, ${gridY}) is a wall`);
                return false;
            }
            
            // Check if there's already a snare seed trap here
            const existingTrap = activeSnareSeedTraps.find(trap => 
                trap.userData.gridX === gridX && trap.userData.gridY === gridY
            );
            if (existingTrap) {
                console.log(`Position (${gridX}, ${gridY}) already has a snare seed trap`);
                return false;
            }
            
            // Check if player is at this position
            const playerGrid = worldToGrid(player.position.x, player.position.z);
            if (gridX === playerGrid.x && gridY === playerGrid.y) {
                console.log(`Position (${gridX}, ${gridY}) is occupied by player`);
                return false;
            }
            
            // Create the snare seed trap
            const worldPos = gridToWorld(gridX, gridY);
            
            // Create seed pod on the ground
            const seedSize = TILE_SIZE * 0.3;
            const seedPod = createSeedPodShape(seedSize);
            
            // Apply brown material with subtle glow
            seedPod.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshPhongMaterial({
                        color: '#8b4513', // Brown
                        emissive: '#654321', // Darker brown emissive
                        emissiveIntensity: 0.2,
                        shininess: 60,
                        transparent: true,
                        opacity: 0.8
                    });
                }
            });
            
            seedPod.position.set(worldPos.x, TILE_SIZE * 0.1, worldPos.z); // Low on ground
            
            // Store trap data
            seedPod.userData = {
                isActiveTrap: true,
                gridX: gridX,
                gridY: gridY,
                trapType: 'snare_seed'
            };
            
            // Add to scene and tracking array
            mazeObjects.add(seedPod);
            activeSnareSeedTraps.push(seedPod);
            
            console.log(`Snare seed trap created at (${gridX}, ${gridY})`);
            return true;
        }
        
        // 🐒 MONKEY DECOY DEPLOYMENT AND MOVEMENT SYSTEM
        function deployMonkeyDecoy() {
            if (!hasDecoy || activeDecoy) {
                console.log('⚠️ Cannot deploy decoy: not available or already active');
                return;
            }
            
            console.log('🐒 Deploying Monkey Decoy!');
            hasDecoy = false; // Consume the decoy
            
            // Create the decoy at player's position - looks like a faded Pac-Man
            const decoyGroup = new THREE.Group();
            
            // Create faded yellow Pac-Man sphere (similar to player but with transparency)
            const sphereGeo = new THREE.SphereGeometry(0.4 * TILE_SIZE, 32, 16, 0, Math.PI * 2, 0, Math.PI);
            sphereGeo.rotateX(-Math.PI / 2);
            const decoyMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFF00, // Same yellow as player
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6 // Faded appearance
            });
            
            // Create top and bottom halves like the real player
            const topHalf = new THREE.Mesh(sphereGeo, decoyMat);
            const bottomHalf = new THREE.Mesh(sphereGeo, decoyMat);
            bottomHalf.rotation.x = Math.PI;
            
            // Add some visual distinction - slight glow effect
            const glowMat = new THREE.MeshStandardMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.3,
                emissive: 0x444400
            });
            const glowSphere = new THREE.SphereGeometry(0.45 * TILE_SIZE, 16, 8);
            const glow = new THREE.Mesh(glowSphere, glowMat);
            
            decoyGroup.add(glow);
            decoyGroup.add(topHalf);
            decoyGroup.add(bottomHalf);
            
            // Add animated mouth movement like the real player
            decoyGroup.userData.top = topHalf;
            decoyGroup.userData.bottom = bottomHalf;
            decoyGroup.userData.mouthAngle = 0;
            
            // Add movement trail particles
            const trailParticles = [];
            for (let i = 0; i < 5; i++) {
                const particleGeo = new THREE.SphereGeometry(0.02, 6, 6);
                const particleMat = new THREE.MeshStandardMaterial({
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.4 - (i * 0.05)
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                trailParticles.push(particle);
                decoyGroup.add(particle);
            }
            
            // Position decoy at player location
            decoyGroup.position.copy(player.position);
            decoyGroup.userData = { 
                type: 'monkey-decoy',
                trailParticles: trailParticles
            };
            
            // Set initial movement direction (player's current facing direction)
            decoyDirection = {
                x: player.userData.direction.x,
                z: player.userData.direction.z
            };
            
            // If player isn't moving, pick a random direction
            if (decoyDirection.x === 0 && decoyDirection.z === 0) {
                const directions = [
                    { x: 1, z: 0 }, { x: -1, z: 0 },
                    { x: 0, z: 1 }, { x: 0, z: -1 }
                ];
                const randomDir = directions[Math.floor(Math.random() * directions.length)];
                decoyDirection = randomDir;
            }
            
            activeDecoy = decoyGroup;
            decoyTimer = DECOY_DURATION;
            
            mazeObjects.add(decoyGroup);
            
            // Play deployment sound and show message
            sounds.powerPellet(); // Temporary sound
            showMessage('🐒 MONKEY DECOY DEPLOYED! (5 seconds)', 2000);
            updateDecoyUI(); // Update UI to show active status
            updateDecoyUI(); // Update UI to show active status
            
            console.log('🐒 Decoy deployed with direction:', decoyDirection);
        }
        
        function updateMonkeyDecoy(deltaTime) {
            if (!activeDecoy) return;
            
            // Update timer
            decoyTimer -= deltaTime;
            
            // Check if decoy should expire
            if (decoyTimer <= 0) {
                removeMonkeyDecoy();
                return;
            }
            
            // Move the decoy
            const moveSpeed = DECOY_SPEED;
            const deltaSeconds = deltaTime / 1000; // Convert ms to seconds
            const newX = activeDecoy.position.x + (decoyDirection.x * moveSpeed * deltaSeconds);
            const newZ = activeDecoy.position.z + (decoyDirection.z * moveSpeed * deltaSeconds);
            
            console.log(`🐒 Decoy moving: pos(${activeDecoy.position.x.toFixed(2)}, ${activeDecoy.position.z.toFixed(2)}) dir(${decoyDirection.x}, ${decoyDirection.z}) speed:${moveSpeed}`);
            
            // Check for wall collision
            const gridX = Math.round(newX / TILE_SIZE);
            const gridZ = Math.round(newZ / TILE_SIZE);
            
            if (isValidPosition(gridX, gridZ)) {
                // Update decoy position
                activeDecoy.position.x = newX;
                activeDecoy.position.z = newZ;
                
                // Update trail particles
                const trailParticles = activeDecoy.userData.trailParticles;
                if (trailParticles && Array.isArray(trailParticles)) {
                    for (let i = trailParticles.length - 1; i > 0; i--) {
                        if (trailParticles[i] && trailParticles[i - 1] && trailParticles[i].position && trailParticles[i - 1].position) {
                            trailParticles[i].position.copy(trailParticles[i - 1].position);
                        }
                    }
                    if (trailParticles.length > 0 && trailParticles[0] && trailParticles[0].position) {
                        trailParticles[0].position.copy(activeDecoy.position);
                        trailParticles[0].position.y += 0.1;
                    }
                }
            } else {
                // Hit a wall - bounce off by changing direction
                console.log('🐒 Decoy hit a wall and bounced');
                
                // Try to find a new valid direction
                const directions = [
                    { x: 1, z: 0 }, { x: -1, z: 0 },
                    { x: 0, z: 1 }, { x: 0, z: -1 }
                ];
                
                // Filter out directions that lead to walls
                const validDirections = directions.filter(dir => {
                    const testX = Math.round((activeDecoy.position.x + dir.x * TILE_SIZE * 0.5) / TILE_SIZE);
                    const testZ = Math.round((activeDecoy.position.z + dir.z * TILE_SIZE * 0.5) / TILE_SIZE);
                    return isValidPosition(testX, testZ);
                });
                
                console.log(`🐒 Found ${validDirections.length} valid directions:`, validDirections);
                
                if (validDirections.length > 0) {
                    // Pick a random valid direction (prefer not going back)
                    const notBackward = validDirections.filter(dir => 
                        !(dir.x === -decoyDirection.x && dir.z === -decoyDirection.z)
                    );
                    const chooseFrom = notBackward.length > 0 ? notBackward : validDirections;
                    decoyDirection = chooseFrom[Math.floor(Math.random() * chooseFrom.length)];
                    console.log(`🐒 New decoy direction:`, decoyDirection);
                } else {
                    // No valid directions - just reverse
                    decoyDirection = { x: -decoyDirection.x, z: -decoyDirection.z };
                    console.log('🐒 No valid directions, reversing:', decoyDirection);
                }
            }
            
            // Add floating animation and mouth movement
            activeDecoy.rotation.y += 0.05; // Slightly faster rotation to show it's different
            activeDecoy.position.y = 0.2 + Math.sin(Date.now() * 0.01) * 0.1; // More pronounced floating
            
            // Animate mouth like the real player
            if (activeDecoy.userData.top && activeDecoy.userData.bottom) {
                const velocity = Math.sqrt(decoyDirection.x * decoyDirection.x + decoyDirection.z * decoyDirection.z);
                activeDecoy.userData.mouthAngle += 20 * (deltaTime / 1000) * (velocity > 0 ? 1 : -1); // Faster mouth movement
                activeDecoy.userData.mouthAngle = Math.max(0, Math.min(Math.PI / 3, activeDecoy.userData.mouthAngle)); // Wider mouth
                activeDecoy.userData.top.rotation.z = activeDecoy.userData.mouthAngle;
                activeDecoy.userData.bottom.rotation.z = -activeDecoy.userData.mouthAngle;
            }
        }
        
        function removeMonkeyDecoy() {
            if (!activeDecoy) return;
            
            console.log('🐒 Monkey Decoy disappeared');
            
            // Create vanish effect
            const particles = [];
            for (let i = 0; i < 10; i++) {
                const particleGeo = new THREE.SphereGeometry(0.02, 4, 4);
                const particleMat = new THREE.MeshStandardMaterial({
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(activeDecoy.position);
                particle.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.5
                ));
                
                // Animate particles upward
                const animateParticle = () => {
                    particle.position.y += 0.02;
                    particle.material.opacity *= 0.95;
                    
                    if (particle.material.opacity > 0.1) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        mazeObjects.remove(particle);
                    }
                };
                
                mazeObjects.add(particle);
                particles.push(particle);
                animateParticle();
            }
            
            mazeObjects.remove(activeDecoy);
            activeDecoy = null;
            decoyTimer = 0;
            
            // Play vanish sound
            sounds.pellet(); // Temporary sound
            showMessage('🐒 Decoy vanished!', 1500);
            updateDecoyUI(); // Update UI to show no decoy
            updateDecoyUI(); // Update UI to show no decoy
        }

        function removeSnareSeedTrap(trap) {
            // Remove from scene
            if (trap.parent) {
                trap.parent.remove(trap);
            }
            
            // Remove from tracking array
            const index = activeSnareSeedTraps.indexOf(trap);
            if (index > -1) {
                activeSnareSeedTraps.splice(index, 1);
            }
            
            console.log(`Snare seed trap removed at (${trap.userData.gridX}, ${trap.userData.gridY})`);
        }

        function createVineEntanglement(ghost, ghostPosition) {
            console.log('Creating vine entanglement effect at ghost position...');
            
            // Create vine entanglement visual effect
            const vineGroup = new THREE.Group();
            
            // Create multiple vine strands wrapping around the ghost
            const vineCount = 8; // Number of vine strands
            const vineHeight = TILE_SIZE * 1.5;
            const vineRadius = TILE_SIZE * 0.4;
            
            for (let i = 0; i < vineCount; i++) {
                const angle = (i / vineCount) * Math.PI * 2;
                const spiralHeight = 15; // Number of spiral turns
                const points = [];
                
                // Create spiral vine path
                for (let j = 0; j <= spiralHeight; j++) {
                    const spiralAngle = angle + (j / spiralHeight) * Math.PI * 4; // 2 full rotations
                    const heightRatio = j / spiralHeight;
                    const currentRadius = vineRadius * (1 - heightRatio * 0.3); // Taper toward top
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const y = heightRatio * vineHeight;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                // Create vine geometry
                const vineGeometry = new THREE.TubeGeometry(
                    new THREE.CatmullRomCurve3(points),
                    20, // tubular segments
                    TILE_SIZE * 0.02, // radius
                    8, // radial segments
                    false // closed
                );
                
                const vineMaterial = new THREE.MeshPhongMaterial({
                    color: '#228b22', // Forest green
                    emissive: '#006400',
                    emissiveIntensity: 0.1,
                    shininess: 40
                });
                
                const vine = new THREE.Mesh(vineGeometry, vineMaterial);
                vineGroup.add(vine);
                
                // Add small leaves along the vine
                for (let k = 2; k < points.length - 2; k += 3) {
                    const leafGeometry = new THREE.PlaneGeometry(TILE_SIZE * 0.08, TILE_SIZE * 0.12);
                    const leafMaterial = new THREE.MeshPhongMaterial({
                        color: '#32cd32', // Lime green
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.position.copy(points[k]);
                    leaf.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    vineGroup.add(leaf);
                }
            }
            
            // Position vine group at ghost's current position (not trap position)
            vineGroup.position.copy(ghostPosition);
            vineGroup.position.y = 0; // Ground level
            
            // Add animation data
            vineGroup.userData = {
                isVineEntanglement: true,
                animationTime: 0,
                targetGhost: ghost,
                followGhost: true // Flag to make vines follow ghost
            };
            
            // Add to scene
            scene.add(vineGroup);
            
            // Store reference in ghost
            ghost.userData.vineEntanglement = vineGroup;
            
            console.log(`Vines created at ghost position: (${ghostPosition.x.toFixed(2)}, ${ghostPosition.z.toFixed(2)})`);
            
            return vineGroup;
        }

        function updateVineEntanglements(delta) {
            // Find all vine entanglements in the scene
            const vineEntanglements = [];
            scene.traverse((child) => {
                if (child.userData && child.userData.isVineEntanglement) {
                    vineEntanglements.push(child);
                }
            });
            
            vineEntanglements.forEach((vineGroup) => {
                vineGroup.userData.animationTime += delta * 2;
                
                // Make vines follow the entangled ghost
                if (vineGroup.userData.followGhost && vineGroup.userData.targetGhost) {
                    const ghost = vineGroup.userData.targetGhost;
                    if (ghost.userData.state === 'entangled') {
                        // Update vine position to ghost's current position
                        vineGroup.position.x = ghost.position.x;
                        vineGroup.position.z = ghost.position.z;
                        vineGroup.position.y = 0; // Keep at ground level
                    }
                }
                
                // Animate vines growing and swaying
                const swayAmount = Math.sin(vineGroup.userData.animationTime) * 0.1;
                vineGroup.rotation.y = swayAmount;
                
                // Make vines pulse slightly
                const pulseScale = 1 + Math.sin(vineGroup.userData.animationTime * 3) * 0.05;
                vineGroup.scale.setScalar(pulseScale);
            });
        }
        
        function updateStickyBlockInteraction() {
            if (!player) return;
            
            const playerGrid = worldToGrid(player.position.x, player.position.z);
            const currentTile = getTile(playerGrid.x, playerGrid.y);
            
            // Reset speed modifier
            let newSpeedModifier = 1.0;
            let newStickyStatus = false;
            
            // Check if player is on a sticky block
            if (currentTile === 0 && isStickyBlock(playerGrid.x, playerGrid.y)) {
                // Player is on a sticky block - check if centered
                const isPlayerPerfectlyCentered = isPlayerCentered(player.position, playerGrid);
                
                if (!isPlayerPerfectlyCentered) {
                    // Player is not centered - apply speed reduction
                    newSpeedModifier = 0.7; // 30% speed reduction
                    newStickyStatus = true;
                    
                    // Visual feedback for being stuck
                    if (!isPlayerOnStickyBlock) {
                        console.log('Player stuck in mud! Move to center to escape.');
                        createStickyParticleEffect(player.position);
                    }
                } else {
                    // Player is perfectly centered - no speed reduction
                    if (isPlayerOnStickyBlock) {
                        console.log('Player escaped sticky mud by staying centered!');
                    }
                }
            }
            
            // Update player speed based on sticky block interaction
            if (dashActive || dashTimer > 0) {
                // Don't modify dash speed
            } else {
                if (newSpeedModifier !== playerSpeedModifier) {
                    playerSpeedModifier = newSpeedModifier;
                    playerSpeed = BASE_PLAYER_SPEED * playerSpeedModifier;
                }
            }
            
            isPlayerOnStickyBlock = newStickyStatus;
        }
        
        function createStickyParticleEffect(position) {
            // Create mud splatter particles
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 4, 4),
                        new THREE.MeshBasicMaterial({
                            color: 0x4a5d23,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    particle.position.set(
                        position.x + (Math.random() - 0.5) * TILE_SIZE * 0.4,
                        -0.2,
                        position.z + (Math.random() - 0.5) * TILE_SIZE * 0.4
                    );
                    
                    mazeObjects.add(particle);
                    
                    // Animate particle
                    const animate = () => {
                        particle.position.y += 0.02;
                        particle.material.opacity -= 0.02;
                        
                        if (particle.material.opacity > 0 && particle.position.y < 0.3) {
                            requestAnimationFrame(animate);
                        } else {
                            mazeObjects.remove(particle);
                        }
                    };
                    animate();
                }, i * 30);
            }
        }
        
        function updateStickyBlocks(delta) {
            // Animate sticky blocks with subtle pulsing effect
            stickyBlocks.forEach(stickyBlock => {
                if (stickyBlock.userData) {
                    stickyBlock.userData.animationTime += delta * 2;
                    
                    // Subtle pulsing animation
                    const pulse = 1 + Math.sin(stickyBlock.userData.animationTime) * 0.02;
                    stickyBlock.scale.setScalar(pulse);
                    
                    // Make border glow slightly
                    stickyBlock.children.forEach(child => {
                        if (child.material && child.material.color) {
                            const isRing = child.geometry.type === 'RingGeometry';
                            if (isRing) {
                                child.material.opacity = 0.6 + Math.sin(stickyBlock.userData.animationTime * 2) * 0.2;
                            }
                        }
                    });
                }
            });
        }

        function removeVineEntanglement(vineGroup) {
            if (vineGroup && vineGroup.parent) {
                vineGroup.parent.remove(vineGroup);
                console.log('Vine entanglement removed');
            }
        }

        // Ice Wall mechanics for Chapter 2
        function updateIceWallUI() {
            // Update UI to show ice wall charges (could add visual indicator later)
            console.log(`Ice Wall charges: ${iceWallCharges}`);
        }

        function createTemporaryIceBlock(gridX, gridY) {
            // Get current level map
            const currentLevelMap = levelMaps[currentChapterIndex];
            
            console.log(`Attempting to place ice block at grid (${gridX}, ${gridY})`);
            
            // Check if position is valid and not already occupied
            if (gridY < 0 || gridY >= currentLevelMap.length || 
                gridX < 0 || gridX >= currentLevelMap[gridY].length) {
                console.log(`Position (${gridX}, ${gridY}) is out of bounds`);
                return false;
            }
            
            // Don't place on walls or existing ice blocks
            if (currentLevelMap[gridY][gridX] === 1) {
                console.log(`Position (${gridX}, ${gridY}) is a wall (tile value: ${currentLevelMap[gridY][gridX]})`);
                return false;
            }
            
            // Check if there's already a temporary ice block here
            const existingBlock = temporaryIceBlocks.find(block => 
                block.userData.gridX === gridX && block.userData.gridY === gridY
            );
            if (existingBlock) {
                console.log(`Position (${gridX}, ${gridY}) already has an ice block`);
                return false;
            }
            
            // Check if player is at this position
            const playerGrid = worldToGrid(player.position.x, player.position.z);
            const playerGridX = playerGrid.x;
            const playerGridZ = playerGrid.y;
            if (gridX === playerGridX && gridY === playerGridZ) {
                console.log(`Position (${gridX}, ${gridY}) is occupied by player`);
                return false;
            }
            
            console.log(`Position (${gridX}, ${gridY}) is valid! Creating ice block...`);
            
            // Create 3D ice block
            const blockSize = TILE_SIZE * 0.9;
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const material = new THREE.MeshPhongMaterial({
                color: '#87ceeb',
                emissive: '#4682b4',
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            const iceBlock = new THREE.Mesh(geometry, material);
            const worldPos = gridToWorld(gridX, gridY);
            iceBlock.position.set(worldPos.x, TILE_SIZE / 2, worldPos.z);
            
            // Store grid position for collision detection
            iceBlock.userData.gridX = gridX;
            iceBlock.userData.gridY = gridY;
            iceBlock.userData.isTemporaryIceBlock = true;
            
            // Add to scene and tracking array
            mazeObjects.add(iceBlock);
            temporaryIceBlocks.push(iceBlock);
            
            // Set timer to remove after 4 seconds
            setTimeout(() => {
                removeTemporaryIceBlock(iceBlock);
            }, 4000);
            
            console.log(`Ice block placed at (${gridX}, ${gridY})`);
            return true;
        }

        function removeTemporaryIceBlock(iceBlock) {
            // Remove from scene
            if (iceBlock.parent) {
                iceBlock.parent.remove(iceBlock);
            }
            
            // Remove from tracking array
            const index = temporaryIceBlocks.indexOf(iceBlock);
            if (index > -1) {
                temporaryIceBlocks.splice(index, 1);
            }
            
            console.log(`Ice block melted at (${iceBlock.userData.gridX}, ${iceBlock.userData.gridY})`);
        }

        function placeIceWall() {
            if (iceWallCharges <= 0) {
                console.log('No ice wall charges available!');
                return;
            }
            
            if (currentChapterIndex !== 1) {
                console.log('Ice walls only work in Chapter 2!');
                return;
            }
            
            // Get player's current grid position using proper conversion
            const playerGrid = worldToGrid(player.position.x, player.position.z);
            const playerGridX = playerGrid.x;
            const playerGridZ = playerGrid.y; // Note: worldToGrid returns {x, y} where y is the Z coordinate
            
            console.log(`Player world position: (${player.position.x.toFixed(2)}, ${player.position.z.toFixed(2)})`);
            console.log(`Player grid position: (${playerGridX}, ${playerGridZ})`);
            
            // Try multiple positions around the player to place ice wall
            const possiblePositions = [
                { x: playerGridX, y: playerGridZ + 1 }, // Behind (positive Z)
                { x: playerGridX, y: playerGridZ - 1 }, // Front (negative Z)
                { x: playerGridX + 1, y: playerGridZ }, // Right
                { x: playerGridX - 1, y: playerGridZ }, // Left
                { x: playerGridX + 1, y: playerGridZ + 1 }, // Diagonal back-right
                { x: playerGridX - 1, y: playerGridZ + 1 }, // Diagonal back-left
                { x: playerGridX + 1, y: playerGridZ - 1 }, // Diagonal front-right
                { x: playerGridX - 1, y: playerGridZ - 1 }  // Diagonal front-left
            ];
            
            // Get player's movement direction for priority placement
            const direction = player.userData.direction;
            let priorityPosition = possiblePositions[0]; // Default to behind
            
            if (direction && (Math.abs(direction.x) > 0.1 || Math.abs(direction.z) > 0.1)) {
                // Determine priority position based on movement direction
                if (Math.abs(direction.x) > Math.abs(direction.z)) {
                    // Moving horizontally
                    if (direction.x > 0) {
                        // Moving right, place behind to the left
                        priorityPosition = { x: playerGridX - 1, y: playerGridZ };
                    } else {
                        // Moving left, place behind to the right
                        priorityPosition = { x: playerGridX + 1, y: playerGridZ };
                    }
                } else {
                    // Moving vertically
                    if (direction.z > 0) {
                        // Moving forward (positive Z), place behind (negative Z)
                        priorityPosition = { x: playerGridX, y: playerGridZ - 1 };
                    } else {
                        // Moving backward (negative Z), place ahead (positive Z)
                        priorityPosition = { x: playerGridX, y: playerGridZ + 1 };
                    }
                }
                console.log(`Direction: (${direction.x.toFixed(2)}, ${direction.z.toFixed(2)}), Priority position: (${priorityPosition.x}, ${priorityPosition.y})`);
            }
            
            // Try priority position first, then other positions
            const orderedPositions = [priorityPosition, ...possiblePositions.filter(pos => 
                pos.x !== priorityPosition.x || pos.y !== priorityPosition.y
            )];
            
            // Try to place ice block at first available position
            for (const pos of orderedPositions) {
                console.log(`Trying to place ice wall at: (${pos.x}, ${pos.y})`);
                if (createTemporaryIceBlock(pos.x, pos.y)) {
                    iceWallCharges--;
                    updateIceWallUI();
                    console.log(`Ice wall placed at (${pos.x}, ${pos.y})! Remaining charges: ${iceWallCharges}`);
                    return;
                }
            }
            
            console.log('Cannot place ice wall at any nearby location!');
        }

        // Spacebar event listener for ice wall placement
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                placeIceWall();
            }
        });

        
        // Visual warning system for cracking floors
        let crackWarnings = new Map();
        
        function addCrackWarning(gridX, gridY) {
            const key = `${gridX},${gridY}`;
            if (crackWarnings.has(key)) return;
            
            const worldPos = gridToWorld(gridX, gridY);
            const warningGeo = new THREE.RingGeometry(TILE_SIZE * 0.3, TILE_SIZE * 0.5, 16);
            const warningMat = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const warning = new THREE.Mesh(warningGeo, warningMat);
            warning.rotation.x = -Math.PI / 2;
            warning.position.set(worldPos.x, -TILE_SIZE / 2 + 0.03, worldPos.z);
            
            crackWarnings.set(key, warning);
            mazeObjects.add(warning);
        }
        
        function updateCrackWarning(gridX, gridY, progress) {
            const key = `${gridX},${gridY}`;
            const warning = crackWarnings.get(key);
            
            if (warning) {
                // Increase intensity as time progresses
                const intensity = Math.min(progress, 1.0);
                warning.material.opacity = 0.3 + (intensity * 0.4);
                warning.material.color.setRGB(1, 1 - intensity, 1 - intensity);
                
                // Add pulsing effect in final 0.3 seconds
                if (progress > 0.7) {
                    const pulse = Math.sin(Date.now() * 0.02) * 0.1 + 0.9;
                    warning.scale.setScalar(pulse);
                }
            }
        }
        
        function removeCrackWarning(gridX, gridY) {
            const key = `${gridX},${gridY}`;
            const warning = crackWarnings.get(key);
            
            if (warning) {
                mazeObjects.remove(warning);
                crackWarnings.delete(key);
            }
        }
        
        function clearAllCrackWarnings() {
            crackWarnings.forEach(warning => {
                mazeObjects.remove(warning);
            });
            crackWarnings.clear();
        }

        // --- INITIALIZATION ---
        loadSettings();
        
        // Show home screen first
        homeScreen.style.display = 'block';
        chapterSelectScreen.style.display = 'none';
        levelSelectScreen.style.display = 'none';
        powerupTutorialScreen.style.display = 'none';
        
        // Ensure start button works - multiple backup methods
        window.addEventListener('load', function() {
            const startBtn = document.getElementById('start-game-home-button');
            if (startBtn) {
                startBtn.addEventListener('click', function() {
                    showChapterSelect();
                });
                // Force the button to be clickable
                startBtn.style.pointerEvents = 'auto';
                startBtn.style.cursor = 'pointer';
            }
        });
        
        animate();
    </script>
 </body>
</html>